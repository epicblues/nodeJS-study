# 이것이 코딩 테스트다 요약

## 복잡도

---

- 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
- 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양

### 시간 복잡도

| 빅오 표기법        | 명칭                     |
| ------------------ | ------------------------ |
| _O(1)_             | 상수 시간(Constant time) |
| _O(N)_             | 선형 시간                |
| _O(logN)_          | 로그 시간                |
| _O(NlogN)_         | 로그 선형 시간           |
| _O(N<sup>2</sup>_) | 이차 시간                |
| _O(N<sup>3</sup>_) | 삼차 시간                |
| _O(2<sup>n</sup>_) | 지수 시간                |

- 빅오 표기법이 항상 절대적인 것은 아니다
- 일반적으로 코딩 테스트 환경에서는 O(N<sup>3</sup>)을 넘어가면 문제 풀이에서 사용하기 어렵다.
- **WHY?** CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서는 연산 횟수가 10억을 넘어가면 C언어를 기준으로 통상 1초 이상의 시간이 소요된다.

| N의 범위   | 시간 복잡도        |
| ---------- | ------------------ |
| 500        | _O(N<sup>3</sup>_) |
| 2000       | _O(N<sup>2</sup>)_ |
| 100,000    | _O(NlogN)_         |
| 10,000,000 | _O(N)_             |

---

### 공간 복잡도

- 코딩 테스트에서는 보통 메모리 사용량을 128~512MB로 제한한다.
- 일반적인 경우 데이터의 개수가 1,000만 단위가 넘어가지 않도록 설계해야 한다.

---

## 출제 경향

- 주로 기초 알고리즘에 기반하는 문제가 출제된다.

#### Top 3

1. 그리디
2. 구현
3. DFS/BFS 활용 탐색 문제

---

# 그리디 알고리즘

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
  - <u>**가장 적은**</u> 동전으로 거스름돈 계산하기(<u>**가장 큰**</u> 화페 단위부터)
- 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 <u>정당한지 검토해야 한다</u>.
  - 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 **<u>_가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다._</u>**
- 어떤 코딩 테스트 문제를 만났을 때, 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심해보자.

# 구현

- 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

## 구현하기 어려운 문제

1. 알고리즘은 간단한데 코드가 지나칠 만틈 길어지는 문제
2. 특정 소수점 자리까지 출력해야 하는 문제
3. 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱을 해야 하는) 문제

## 완전 탐색

- 모든 경우의 수를 주저 없이 다 계산하는 해결법

## 시뮬레이션

- 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

## int 자료형 데이터의 개수에 따른 메모리 사용량

| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| ---------------------------- | ------------- |
| 1,000                        | 약 4KB        |
| 1,000,000                    | 약 4MB        |
| 10,000,000                   | 약 40MB       |

## 구현 문제 접근법

- 보통 구현 유형의 문제는 사소한 입력 조건 등을 문제에서 명시해주며 문제의 길이가 꽤 긴 편이다.

# DFS/BFS

## 자료구조 기초

- 탐색
  - **많은 양의 데이터 중에서 원하는 데이터를 찾는 과정**
- 자료구조
  - **데이터를 표현하고 관리하고 처리하기 위한 구조**
  - **OverFlow**
    - 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 **삽입 연산**을 수행할 때 발생
  - **UnderFlow**
    - 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 **삭제 연산**을 수행할 때

* 수학에서 **점화식**은 특정한 함수를 자신보다 **더 작은 변수**에 대한 함수와의 관계로 표현한 것을 의미한다.

- 그래프 표현 방식

  - 인접 행렬(Adjacency MAtrix) : 2차원 배열로 그래프의 연결 관계 표현

  ```javascript
  const INF = 99999999; // 무한의 비용 선언
  // 연결되어 있지 않은 노드 끼리의 관계 표현
  // 논리적으로 정답이 될 수 없는 값
  
  // 2차원 리스트를 이용해 인접 행렬 표현
  graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0],
  ];
  ```

  - 인접 리스트(Adjacency List) : 리스트와 그래프의 연결 관계를 포현하는 방식
    - 파이썬이나 자바스크립트에서는 기본 자료형으로 인접 리스트 표현 가능(결국 2차원 배열 활용하면 됨)

```javascript
// 행이 3개인 2차원 리스트로 인접 리스트 표현
const graph = Array(3)
  .fill()
  .map((a) => []);

// 노드 0에 연결된 노드정보 저장(노드, 거리)
graph[0].push([1, 7]);
graph[0].push([2, 5]);

// 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].push([0, 7]);

// 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].push([0, 5]);

console.log(graph);
```

- 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.
- 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
- 하지만 이와 같은 속성 떄문에 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는 정보를 얻는 속도가 느리다.

## DFS 작동 순서

#### ✍️ 실제로 스택을 쓰지 않아도 된다.

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 **최상단 노드**(_맨 위에 쌓여 있는_)에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

## DFS 동작 순서

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내(**dequeue**) 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 떄까지 반복한다.

- 코딩 테스트 중 2차원 배열에서의 탐색 문제를 만나면 이렇게 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다.

# 정렬

- 정렬 알고리즘으로 데이터를 정렬하면 이진 탐색이 가능

## 선택 정렬

- 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복

- 선택 정렬은 코딩 테스트에서 사용하기에 매우 비효율적이나, 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 소스코드에 익숙해질 필요가 있다.

  ```javascript
  const array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];
  for (i = 0; i < array.length; i++) {
    // 시작점
    let min_index = i;
    for (let j = i; j < array.length; j++) {
      // 특정한 리스트에서 가장 작은 데이터 찾기
      if (array[j] < array[min_index]) {
        min_index = j;
      }
    }
    const temp = array[i];
    array[i] = array[min_index];
    array[min_index] = temp;
  }
  console.log(array);
  ```

  ## 삽입 정렬

  - "데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?"

  - 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.

    ```bash
    # 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입된다는 점이 특징이다.
    ```

  - 삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 첫 번쨰 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.

  - 원소가 정렬이 이루어져 있기 때문에 새로운 원소를 넣을 때 그 원소보다 작거나 (오름차순) 큰(오름차순) 조건을 만족시키면 그 자리에 원소를 넣으면 된다.

  ```javascript
  const array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

  for (let i = 1; i < array.length; i++) {
    for (let j = i; j > 0; j--) {
      // 정렬된 나머지 배열 + 정렬 대상 원소 하나를 묶는다.
      // 해당 원소가 제자리(이전 원소보다 큰)를 찾을 떄 까지 순회한다.
      if (array[j] < array[j - 1]) {
        // 비정상
        // 정상으로 바꾼다.
        let temp = array[j];
        array[j] = array[j - 1];
        array[j - 1] = temp;
      } else {
        // 한 번 정상이 되면(이전 원소보다 크면)
        // 나머지 원소보다 큰 것은 보장(오름차순/내림차순)되므로
        // 순회를 종료효ㅏㄴ다.
        break;
      }
    }
  }

  console.log(array);
  ```

  ### 삽입 정렬의 시간 복잡도

  - 삽입 정렬의 시간 복잡도는 O(N<sup>2</sup>)인데, 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용. 최선의 경우 O(N)의 시간 복잡도를 가진다.(**현재 리스트의 데이터가 거의 정렬되어 있는 상태**일 때 빠르게 동작)

  ## 퀵 정렬

- 병합 정렬과 함께 가장 많이 사용되는 알고리즘

  - 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘

- 핵심 아이디어

  - ```
    기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?
    ```

  * 기준(**Pivot**)을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식

  * 호어 분할
    - 리스트에서 첫 번째 데이터를 피벗으로 정한다.

  ```javascript
  const array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8];
  
  function quick(start, end, arr) {
    // 원소가 1개인 경우 종료
    if (start >= end) return;
    let pivot = start;
    let left = start + 1;
    let right = end;
  
    while (left <= right) {
      if (arr[left] > arr[pivot] && arr[right] < arr[pivot]) {
        const temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
      }
  
      if (arr[left] <= arr[pivot]) {
        left++;
      }
      if (arr[right] >= arr[pivot]) {
        right--;
      }
    }
  
    // pivot 기준 정렬 완료
    let temp = arr[pivot];
    arr[pivot] = arr[right];
    arr[right] = temp;
    // 1차 sort 완료;
    // 내가 실수한 것 : 첫 번쨰 sort는 피벗 값에서 시작한다.
    quick(pivot, right - 1, arr);
    quick(right + 1, arr.length - 1, arr);
  }
  
  quick(0, array.length - 1, array);
  ```

  - 퀵 정렬의 시간 복잡도 : _O(NlogN)_

  - \*\*최악의 경우 시간 복잡도가 _O(N<sup>2</sup>)_ 가 될 수 있다.

  - **일반적으로 컴퓨터 과학에서 log의 의미는 밑이 2인 로그를 의미한다.**

    ## 계수 정렬(Count Sort)

    - 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능
      - 모든 범위를 담을 수 있는 크기의 배열을 선언해야 하기 때문에.
    - 계수 정렬은 다른 알고리즘 처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(**비교 기반 정렬 알고리즘**)이 아니다.

    ```javascript
    const arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2];
    
    // 모든 범위를 포함하는 리스트 선언
    const answer = Array(Math.max(...arr) + 1).fill(0);
    
    // arr를 순회하면서 count
    for (let num of arr) {
      answer[num]++;
    }
    
    let buffer = [];
    
    // count 한 것을 출력하기
    for (let k = 0; k < answer.length; k++) {
      for (let i = 0; i < answer[k]; i++) {
        buffer.push(k);
      }
    }
    
    console.log(buffer.join(" "));
    ```

    - 시간 복잡도 (N : 데이터의 개수, K : 데이터의 최대값): _O(N + K)_

    - 공간 복잡도 : _O(N + K)_

      - 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하다.
        - ex) 0과 999999만 존재 -> 공간 복잡도 1000001

      ### 정렬 알고리즘 관련 문제 유형

      1. 정렬 라이브러리로 풀 수 있는 문제
      2. 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택, 삽입, 퀵 정렬 등의 원리 파악해야 풀 수 있다.
      3. 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

      # 이진 탐색
    
      ## 순차 탐색
    
      * 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법
      * 정렬되지 않은 리스트에서 데이터를 찾아야 할 때
      * 시간만 충분하면 **항상** 원하는 데이터를 찾을 수 있다.
    
      ## 이진 탐색
    
      * 이진 탐색의 위치 변수 (**시작점 끝점 중간점**)
      * 중간점의 데이터와 찾으려는 데이터를 비교하고 찾으려는 데이터가 없는 구간을 버린다.
      * 시간복잡도 *O(logN)* 
      * 한 단계를 거칠 때마다 확인하는 원소가 평균적으로 절반으로 줄어든다.
      * **이진 탐색은 코딩 테스트에서 단골로 나오는 문제이니 가급적 외우길 권한다.**
    
      ```javascript
      const arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
      const target = 7;
      let start = 0;
      let end = 9;
      let answer = null;
      // while문 끝내는 조건(찾지 못햇을 때)
      while (start <= end) {
        let mid = Math.floor((start + end) / 2);
        if (arr[mid] === target) {
          answer = mid + 1;
          break;
            // 만약에 start===end===mid 인 상황이 왔는데도
            // target을 찾지 못했을 때
            // end 와 start가 엇갈리기 시작하며
            // while문을 탈출한다.
        } else if (arr[mid] > target) {
            
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      
      console.log(answer ? answer : "없음");
      ```
    
      
