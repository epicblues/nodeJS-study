# SQL 응용

## 트리거

* 트리거는 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 **이벤트**가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.
* 데이터 무결성
  * 데이터베이스에 저장된 데이터 값과 그것이 표현하는 실제 값이 일치하는 정확성을 의미한다.
* 트리거에서는 TCL(COMMIT, ROLLBACK) 트랜잭션 제어어 사용 불가
* 트리거 실행 중 오류 발생
  * 트리거 실행의 원인을 제공한 데이터에도 영향이 간다.

## 사용자 정의 함수

* 절차형 SQL을 활용하여 일련의 연산 처리 결과를 단일 값으로 반환할 수 있는 함수.
* 반환하는 단일 값을 조회 또는 삽입, 수정 작업에 이용한다.
  * 프로시저와의 유일한 차이점.

## SQL

* 데이터 정의어(DDL)
  * 테이블이나 관계의 구조를 생성하는 데 사용
  * CREATE, ALTER, DROP, TRUNCATE
* 데이터 조작어(DML)
  * 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어
* 데이터 제어어(DCL)
  * 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 DBA가 사용하는 제어용 언어
  * GRANT, REVOKE

### DML

* SELECT
  * ALL(기본값)
    * 모든 튜플을 검색할 때 사용
  * DISTINCT
    * 중복된 속성이 조회될 경우 그 중 한개만 검색(SELECT 뒤에 명시된 속성이 중복될 경우 한 개만 검색)
  * DISTINCTROW
    * SELECT 뒤에 속성들과 상관없이 튜플 전체가 중복된 튜플을 제거

### DCL

* GRANT
  * 시스템 권한
    * GRANT 권한 TO 사용자
    * 관리지가 사용자에게 테이블/뷰/프로서지 등을 생성하고 삭제할 수 있는 권할을 부여
  * 객체 권한
    * GRANT 권한 ON 테이블 TO 사용자
    * 관리자가 사용자에게 테이블을 수정, 삽입, 삭제, 조회와 프로시저 실행을 할 수 있는 권한을 부여
  * **WITH GRANT OPTION**
    * 권한이 필요할 경우 다른 사용자에게 부여할 수 있는 권한
* REVOKE
  * **CASCADE CONSTRAINTS**
    * WITH GRANT OPTION으로 부여된 사용자들으권한까지 회수할 수 있다.
* SAVEPOINT 이름;
  * 특정 지점을 지정
* ROLLBACK TO SAVEPOINT 이름;
  * SAVEPOINT로 지정한 부분 이후에 발생한 트랜잭션 취소;

### 윈도우 함수

* OLAP(On-Line Ananlytical Processing)

  * 의사결정 지원 시스템으로, 사용자가 동일한 데이터를 여러 기준을 이용하는 다양한 방식으로 바라보면서 다차원 데이터 분석을할 수 있도록 도와주는 기술

* 문법

  ```SQL
  SELECT 함수명(파라미터)
  OVER
  ([PARTITION BY 컬럼 1,...])
  [ORDER BY 컬럼A, ...]
  FROM 테이블명;
  ```

#### 집계 함수

* STDDEV
  * 복수 행의 해당 컬럼에 대한 표준편사를 구하는 함수
* VARIEN
  * 분산을 구하는 함수

#### 순위 함수

* RANK
  * 특정 항목에 대한 순위
  * 동일 순위의 레코드 존재 시 후순위는 넘어감
    * 2위 3개 중복 -> 다음 순위 5위
* DENSE_RANK
  * 레코드의 순위를 계산하는 함수
  * 동일한 항목이 있어도 후순위로 넘어가지 않음
    * 2,2,2,3,4
* ROW_NUMBER
  * 동일 순위의 값이 존재해도 
    * 무관하게 연속 번호를 ㅂ여

#### 행 순서 함수

* FIRST_VALUE
  * 파티션 별 윈도에서 가장 먼저 나오는 값 반환
  * 집계 함수의 MIN과 동일한 결과 출력
* LAST_VALUE
  * 파티션별 윈도에서 가장 늦게 나오는 값 반환
  * MAX
* LAG
  * 이전 로우의 값을 반환
* LEAD
  * 이후 로우의 값을 반환

#### 그룹 내 비율 함수

* RATIO_TO_REPORT
  * 주어진 그룹에 대해 합을 기준으로 각 로우의 상대적 비율을 반환하는 함수
  * 0~1 범위
* PERCENT_RANK
  * 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로 한다.
  * 값이 아닌 행의 순서별 백분율
  * 0~1 범위

​	

#### OLAP 연산

* Roll-Up
  * 구체적 -> 요약된 형태로 접근
* Drill-Down
  * 요약 -> 구체적
* DRill-Up
  * === Rollup
* Slicing
  * 분석 처리를 위한 자료구조인 데이터 큐브의 한 조각 보기
* Dicing
  * 고정된 다차원 값에 대한 연산
* Pivoting
  * 다차원 분석 테이블인 크로스 테이블에서 차원 변경을 위해 사용되는 연산

### 그룹 함수의 유형

* ROLLUP

  * 지정된 컬럼의 소계 및 총계를 구하기 위해 사용되는 그룹 함수
  * 지정 컬럼의 수보다 하나 더 큰 레벨 만큼 중간 집계 값이 생성된다.

  ```SQL
  SELECT 컬럼명1, .., 그룹 함수
  FROM 테이블명
  GROUP BY [컬럼명1, ...] ROLLUP(그룹화할 열)
  HAVING
  ORDER BY
  ```

* CUBE
  * 결합 가능한 모든 값에 대해 다차원 집계를 생성
  * 내부적으로 대상 컬럼의 순서를 변경하여 또 한번의 쿼리 수행
  * 시스템 부담
* GROUPING SETS
  * 집계 대상 컬럼들에 대한 소계
  * ROLLUP과 달리 컬럼간 순서와 무관한 결과
  * 다양한 소계 집합 만들 수 있다.

# SQL 활용

## DDL

* 데이터를 담는 그릇을 정의

### DDL 대상

* 도메인
  * 하나의 속성이 가질 수 있는 원자값들의 집합
  * 속성의 데이터 타입과 크기, 제약 조건 등의 정보
* 스키마
  * 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  * 외부 스키마
    * 사용자와 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
    * 사용자 뷰
    * 서브 스키마
  * 개념 스키마
    * 데이터베이스의 전체적인 논리적 구조
    * 전체적인 뷰
    * 개체 간의 관계, 제약 조건, 접근 권한, 무결성, 보안에 대해 정의
  * 내부 스키마
    * 물리적 저장장치 관점
    * 실제로 데이터베이스에 저장될 레코드의 형식을 정의, 데이터 항목의 표현 방법, 레코드의 물리적 순서 결정
* 테이블
  * 데이터 저장 공간
* 뷰
  * 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
* 인덱스
  * 검색을 빠르게 하기 위한 데이터 구조

### DDL 명령어

* DROP : 데이터베이스 오브젝트 삭제
* TRUNCATE : 데이터베이스 오브젝트 내용 삭제

```SQL
CREATE TABLE 테이블명
(
	속성명 데이터타입 [NOT NULL], ..., 
    PRIMARY KEY(기본키)
    UNIQUE(속성명, ...)
    FOREIGN KEY(외래키) REFERENCES 참조 테이블(기본 키),
    CONSTRAINT 제약조건명 CHECK(조건식)
)
```

* DROP TABLE 옵션
  * CASCADE : 참조하는 테이블까지 연쇄적으로 제거하는 옵션
  * RESTRICT : 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션
* ALTER TABLE
  * 컬럼 추가
    * ALTER TABLE 테이블명  ADD 컬럼명 데이터_타입;
  * 컬럼 수정
    * ALTER TABLE 테이블명 MODIFY 컬럼명 데이터_타입 [DEFAULT 값] [NOT NULL];
  * 컬럼 삭제
    * ALTER TABLE 테이블명 DROP 컬럼명;
  * 컬럼명 수정
    * ALTER TABEL 테이블명 RENAME COLUMN 변경전컬럼명 TO 변경컬럼명;

### 트랜잭션

* 트랜잭션의 특징
  * 일관성
    * 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상테를 보존해야함
    * 주요 기법
      * 무결성 제약 조건
      * 동시성 제어
    * 트랜잭션이 성공한 후에도 제약조건을 만족해야 한다.
  * 영속성
    * 시스템 종료 후 재시작 상황에서도 DB 내의 데이터가 정상적으로 저장되어 있어야 한다.
* 병행 제어(Concurrency Control)
  * 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다. 
  * 미보장 시 문제점
    * 갱신 손실(Lost Update)
      * 먼저 실행된 트랜잭션 결과를 나중에 실행된 트랜잭션이 덮어 쓸 때
    * 현황 파악 오류
      * 중간 수행 결과를 다른 트랜잭션이 참조
    * 모순성
      * 일관성 결여(동시 실행)
    * 연쇄 복귀(Cascading Rollback)
      * 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류
* 병행 제어 기법
  * 로킹
    * 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보 장ㅎ나는 직렬화 기법
    * 로킹 단위 : 데이터베이스, 파일, 레코드
    * 로킹 단위가 작아지면 데이터베이스 공유도가 증가
    * 작아지면 오버헤드가 증가
    * 한꺼번의 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
  * 낙관적 검증
    * 어떠한 검증도 하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영
  * 타임 스탬프 순서
    * 실행을 시작하기 전에 갱신한 데이터에 대해 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행
  * 다중버전 동시성 제어
    * 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법
* 트랜잭션 상태
  * 활동 상태(Active)
    * 트랜잭션이 실행 중일 때
  * 부분 완료 상태(Partially Comitted)
    * 마지막 명령문이 실행된 후에 가지는 상태
  * 완료 상태
    * 성공적으로 완료
  * 실패 상태
    * 정상적인 실행이 더 이상 진행될 수 없을 때
  * 철회 상태(aborted)
    * 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작가 전 상태로 환원된 상태

### 테이블

* 필드들로 구성된 데이터의 집합체이다.
* 릴레이션 혹은 엔터티라고 부른다.
* 테이블에 포함된 행,열들 간에는 순서가 존재하지 않는다.

* 튜플은 릴레이션에서 같은 값을 가질 수 없음
* Cardinality : 튜플의 개수
* Degree : 차수(속성의 개수)
* **도메인 : 하나의 속성이 취할 수 있는 같은 원자값 들의 집합.**
* 옵티마이저 
  * 사용자가 질의한 SQL 문을 처리할 수 있는 실행 계획을 탐색하고 각 실행 계획에 대한 비용을 추정하여 최적의 실행계획을 수립하는 DBMS의 핵심 엔진이다.

### 뷰

* 논리 테이블로서 사용자에게 테이블과 동일하다.
* 뷰는 하나의 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있다.
* 뷰와 같은 결과를 만들기 위해 조인 기능을 사용할 수 있으나, 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있다.

* 뷰의 특징

  * 논리적 데이터 독립성 제공
    * 데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 접근 가능
  * 데이터 조작 연산 간소화
    * 앱이 원하는 논리적 구조를 형성하여 조작 연산 간소화
  * 보안 기능(접근 제어)
    * 특정 필드만을 선택해 뷰를 생성할 경우 앱은 선택되지 않은 필드의 조회 및 접근 불가
    * 보안 데이터를 저장하는 테이블에서는 보안 데이터를 제외하고 나머지 필드만 보여주는 뷰를 구성할 수 있다.
  * 뷰 변경 불가
    * 뷰 정의는 ALTER 문을 이용하여 변경할 수 없음

* 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있기 때문이다.

  ```sql
  SELECT * FROM 뷰이름;
  ```

  * 뷰 자체 인덱스 불가(인덱스는 물리적으로 저장된 데이터 대상)
  * 삽입, 삭제, 변경 제약

* 뷰 생성

```sql
CREATE VIEW 뷰_이름 컬럼_목록 AS 조회 쿼리
```

* SELECT 문에는 UNION이나 ORDER BY 절을 사용할 수 없다.

### INDEX

* 테이블에 대한 조회 속도를 높여 주는 자료구조다.

* 테이블의 특정 레코드 위치를 알려주는 용도로 사용한다.

* **인덱스는 자동으로 생성되지 않는다**

* 기본 키 컬럼은 자동으로 인덱스가 생성된다.

  ```SQL
  SELECT * FROM 사원 WHERE 이름 = '홍길동';
  ```

  

* '테이블의 이름' 컬럼에 인덱스가 없는 경우, 테이블으전체 내용을 검색한다.(Table Full Scan)

* 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있다.

* INDEX의 종류
  * 순서 인덱스
    * 데이터가 정렬된 순서로 생성되는 인덱스
    * B-Tree 알고리즘 활용(오름차순, 내림차순)
  * 해시 인덱스
    * 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
    * 데이터 접근 비용이 균일, Row 양에 무관
  * 비트맵 인덱스
    * 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스
    * 수정 변경이 적을 경우 유용(생년 월일 상품 번호 등)
  * 함수기반 인덱스
    * 수식이나 함수 적용
  * 단일 인덱스
    * 하나의 컬럼으로만 구성한 인덱스
    * 주 사용 컬럼이 하나일 경우
  * 결합 인덱스
    * 두 개 이상의 컬럼
    * WHERE 조건으로 사용하는 빈도가 높은 경우 사용
  * 클러스터드 인덱스
    * 기본 키 기준으로 레코드를 묶어서 저장하는 인덱스
    * 저장 데이터의 물리적 순서에 따라 인덱스 생성
    * 특정 범위 검색 시 유리

* 인덱스 생성

  ```SQL
  CREATE INDEX 인덱스명 ON 테이블명(컬럼명);
  ```

* 인덱스 삭제 명령시 테이블 변경 명령어가 사용된다.

  * 인덱스가 테이블의 종속 구조로 간주되기 떄문

* 인덱스 스캔 방식
  * 인덱스 범위 스캔
    * 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔
  * 인덱스 전체 스캔
    * 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지
  * 인덱스 단일 스캔
    * 수직적 탐색만으로 데이터 찾기
  * 인덱스 생략 스캔
    * 선두 컬럼이 조건 절에 빠졌어도 인덱스를 활용

### JOIN

* 논리적 조인
  * 사용자 SQL 문에 표현되는 테이블 결합 방식
    * 내부 조인
      * 공통 존재 컬럼의 값이 같은 경우
    * 외부 조인
      * 왼쪽
        * 왼쪽 테이블으모든 데이터와 오른쪽 테이블의 동일 데이터를 추출
      * 오른쪽
        * 오른쪽 모든 데이터
      * 완전
        * 양쪽의 모든 데이터
    * 교차 조인
      * 조인 조건이 없는 모 든 데이터 조합
    * 셀프 조인
      * 자기 자신에게 별칭 지정
* 물리적 조인
  * 데이터베이스 옵티마이저에 의해 내부적으로 발생하는 테이블 결합 방식
    * 중첩 반복 조인(Nested Loop)
      * 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방  Row를 결합하여 원하는 결과를 조합하는 조인 방식이다. 
      * 좁은 범위에 유리한 성능
      * 순차적으로 처리, **Random Access** 위주
      * 후행 테이블에는 조인을 위한 인덱스 생성이 필요하다.
      * 실행속도 = 선행 테이블 사이즈 * 후행 테이블 접근 횟수
    * 정렬 합병 조인(Sort -Merge Join)
      * 조인 대상의 범위가 넓을 경우 발생하는 임의 접근을 줄이기 위한 경우
      * 연결고리에 마땅한 인덱스가 존재하지 않을 경우
      * 양쪽 테이블의 정렬 결과를 차례대로 검색하면서 연결고리 형태로 합병
      * 랜덤 액세스 x 스캔
      * 선행집합 개념이 없다.
      * 정렬을 위한 영역에 따라 효율에 큰 차이가 발생한다.
      * 조인 연산자가 '='이 아닌 경우 중첩 반복 조인보다 유리한 경우가 많다.
    * 해시 조인
      * 해싱 함수를 활용하여 테이블 간 조인을 수행
      * 해싱 함수는 직접적인 연결이 아닌 연결될대상을 특정 지역에 모아두는 역할
      * 비용기반 옵티마이저에서만 가능, CPU 성능 의존적
        * 처리 방법에 대한 비용들을 산정해보고, 그중 가장 적인 비용이 들어가는 처리방법을 선택하는 옵티마이저
      * 해시 테이블 생성후 중첩 반복 조인처럼 순차적인 형태로 수행한다.

### 서브쿼리

* 메인쿼리와 서브쿼리 관계는 주종관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인 쿼리에 컬럼 정보를 사용할 수 있으나 역으로는 성립되지 않는다.
* 단일 행 서브쿼리
  * 결과가 항상 1건 이하인 서브쿼리
  * 단일 행 비교 연산자(=,<= 등) 사용
* 다중 행 서브쿼리
  * 실행 결과가 여러 건인 서브쿼리
  * 다중 행 비교 연산자 사용
  * IN
    * 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건
  * ALL
    * 서브쿼리의 결과에 모든 값을 만족
  * ANY
    * 결과에 어느 하나의 값이라도 만족
  * EXIST
    * 존재 여부 확인
* 다중 컬럼 서브쿼리
  * 메인 쿼리의 조건 절에 여러 컬럼을 동시에 비교할 떄
  * 서브쿼리와 메인 쿼리에서 비교하는 컬럼 개수와 위치가 동일해야함
* SELECT 절에 오는 서브쿼리는 반드시 단일 행을 리턴해야 함.
  * SUM, COUNT, MIN, MAX 과 같은 집계 함수와 많이 쓰임