# SQL 응용

## 트리거

* 트리거는 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 **이벤트**가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.
* 데이터 무결성
  * 데이터베이스에 저장된 데이터 값과 그것이 표현하는 실제 값이 일치하는 정확성을 의미한다.
* 트리거에서는 TCL(COMMIT, ROLLBACK) 트랜잭션 제어어 사용 불가
* 트리거 실행 중 오류 발생
  * 트리거 실행의 원인을 제공한 데이터에도 영향이 간다.

## 사용자 정의 함수

* 절차형 SQL을 활용하여 일련의 연산 처리 결과를 단일 값으로 반환할 수 있는 함수.
* 반환하는 단일 값을 조회 또는 삽입, 수정 작업에 이용한다.
  * 프로시저와의 유일한 차이점.

## SQL

* 데이터 정의어(DDL)
  * 테이블이나 관계의 구조를 생성하는 데 사용
  * CREATE, ALTER, DROP, TRUNCATE
* 데이터 조작어(DML)
  * 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어
* 데이터 제어어(DCL)
  * 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 DBA가 사용하는 제어용 언어
  * GRANT, REVOKE

### DML

* SELECT
  * ALL(기본값)
    * 모든 튜플을 검색할 때 사용
  * DISTINCT
    * 중복된 속성이 조회될 경우 그 중 한개만 검색(SELECT 뒤에 명시된 속성이 중복될 경우 한 개만 검색)
  * DISTINCTROW
    * SELECT 뒤에 속성들과 상관없이 튜플 전체가 중복된 튜플을 제거

### DCL

* GRANT
  * 시스템 권한
    * GRANT 권한 TO 사용자
    * 관리지가 사용자에게 테이블/뷰/프로서지 등을 생성하고 삭제할 수 있는 권할을 부여
  * 객체 권한
    * GRANT 권한 ON 테이블 TO 사용자
    * 관리자가 사용자에게 테이블을 수정, 삽입, 삭제, 조회와 프로시저 실행을 할 수 있는 권한을 부여
  * **WITH GRANT OPTION**
    * 권한이 필요할 경우 다른 사용자에게 부여할 수 있는 권한
* REVOKE
  * **CASCADE CONSTRAINTS**
    * WITH GRANT OPTION으로 부여된 사용자들으권한까지 회수할 수 있다.
* SAVEPOINT 이름;
  * 특정 지점을 지정
* ROLLBACK TO SAVEPOINT 이름;
  * SAVEPOINT로 지정한 부분 이후에 발생한 트랜잭션 취소;

### 윈도우 함수

* OLAP(On-Line Ananlytical Processing)

  * 의사결정 지원 시스템으로, 사용자가 동일한 데이터를 여러 기준을 이용하는 다양한 방식으로 바라보면서 다차원 데이터 분석을할 수 있도록 도와주는 기술

* 문법

  ```SQL
  SELECT 함수명(파라미터)
  OVER
  ([PARTITION BY 컬럼 1,...])
  [ORDER BY 컬럼A, ...]
  FROM 테이블명;
  ```

#### 집계 함수

* STDDEV
  * 복수 행의 해당 컬럼에 대한 표준편사를 구하는 함수
* VARIEN
  * 분산을 구하는 함수

#### 순위 함수

* RANK
  * 특정 항목에 대한 순위
  * 동일 순위의 레코드 존재 시 후순위는 넘어감
    * 2위 3개 중복 -> 다음 순위 5위
* DENSE_RANK
  * 레코드의 순위를 계산하는 함수
  * 동일한 항목이 있어도 후순위로 넘어가지 않음
    * 2,2,2,3,4
* ROW_NUMBER
  * 동일 순위의 값이 존재해도 
    * 무관하게 연속 번호를 ㅂ여

#### 행 순서 함수

* FIRST_VALUE
  * 파티션 별 윈도에서 가장 먼저 나오는 값 반환
  * 집계 함수의 MIN과 동일한 결과 출력
* LAST_VALUE
  * 파티션별 윈도에서 가장 늦게 나오는 값 반환
  * MAX
* LAG
  * 이전 로우의 값을 반환
* LEAD
  * 이후 로우의 값을 반환

#### 그룹 내 비율 함수

* RATIO_TO_REPORT
  * 주어진 그룹에 대해 합을 기준으로 각 로우의 상대적 비율을 반환하는 함수
  * 0~1 범위
* PERCENT_RANK
  * 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로 한다.
  * 값이 아닌 행의 순서별 백분율
  * 0~1 범위

​	

#### OLAP 연산

* Roll-Up
  * 구체적 -> 요약된 형태로 접근
* Drill-Down
  * 요약 -> 구체적
* DRill-Up
  * === Rollup
* Slicing
  * 분석 처리를 위한 자료구조인 데이터 큐브의 한 조각 보기
* Dicing
  * 고정된 다차원 값에 대한 연산
* Pivoting
  * 다차원 분석 테이블인 크로스 테이블에서 차원 변경을 위해 사용되는 연산

### 그룹 함수의 유형

* ROLLUP

  * 지정된 컬럼의 소계 및 총계를 구하기 위해 사용되는 그룹 함수
  * 지정 컬럼의 수보다 하나 더 큰 레벨 만큼 중간 집계 값이 생성된다.

  ```SQL
  SELECT 컬럼명1, .., 그룹 함수
  FROM 테이블명
  GROUP BY [컬럼명1, ...] ROLLUP(그룹화할 열)
  HAVING
  ORDER BY
  ```

* CUBE
  * 결합 가능한 모든 값에 대해 다차원 집계를 생성
  * 내부적으로 대상 컬럼의 순서를 변경하여 또 한번의 쿼리 수행
  * 시스템 부담
* GROUPING SETS
  * 집계 대상 컬럼들에 대한 소계
  * ROLLUP과 달리 컬럼간 순서와 무관한 결과
  * 다양한 소계 집합 만들 수 있다.

# SQL 활용

## DDL

* 데이터를 담는 그릇을 정의

### DDL 대상

* 도메인
  * 하나의 속성이 가질 수 있는 원자값들의 집합
  * 속성의 데이터 타입과 크기, 제약 조건 등의 정보
* 스키마
  * 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  * 외부 스키마
    * 사용자와 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
    * 사용자 뷰
    * 서브 스키마
  * 개념 스키마
    * 데이터베이스의 전체적인 논리적 구조
    * 전체적인 뷰
    * 개체 간의 관계, 제약 조건, 접근 권한, 무결성, 보안에 대해 정의
  * 내부 스키마
    * 물리적 저장장치 관점
    * 실제로 데이터베이스에 저장될 레코드의 형식을 정의, 데이터 항목의 표현 방법, 레코드의 물리적 순서 결정
* 테이블
  * 데이터 저장 공간
* 뷰
  * 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
* 인덱스
  * 검색을 빠르게 하기 위한 데이터 구조

### DDL 명령어

* DROP : 데이터베이스 오브젝트 삭제
* TRUNCATE : 데이터베이스 오브젝트 내용 삭제

```SQL
CREATE TABLE 테이블명
(
	속성명 데이터타입 [NOT NULL], ..., 
    PRIMARY KEY(기본키)
    UNIQUE(속성명, ...)
    FOREIGN KEY(외래키) REFERENCES 참조 테이블(기본 키),
    CONSTRAINT 제약조건명 CHECK(조건식)
)
```

* DROP TABLE 옵션
  * CASCADE : 참조하는 테이블까지 연쇄적으로 제거하는 옵션
  * RESTRICT : 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션
* ALTER TABLE
  * 컬럼 추가
    * ALTER TABLE 테이블명  ADD 컬럼명 데이터_타입;
  * 컬럼 수정
    * ALTER TABLE 테이블명 MODIFY 컬럼명 데이터_타입 [DEFAULT 값] [NOT NULL];
  * 컬럼 삭제
    * ALTER TABLE 테이블명 DROP 컬럼명;
  * 컬럼명 수정
    * ALTER TABEL 테이블명 RENAME COLUMN 변경전컬럼명 TO 변경컬럼명;

### 트랜잭션

* 트랜잭션의 특징
  * 일관성
    * 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상테를 보존해야함
    * 주요 기법
      * 무결성 제약 조건
      * 동시성 제어
    * 트랜잭션이 성공한 후에도 제약조건을 만족해야 한다.
  * 영속성
    * 시스템 종료 후 재시작 상황에서도 DB 내의 데이터가 정상적으로 저장되어 있어야 한다.
* 병행 제어(Concurrency Control)
  * 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다. 
  * 미보장 시 문제점
    * 갱신 손실(Lost Update)
      * 먼저 실행된 트랜잭션 결과를 나중에 실행된 트랜잭션이 덮어 쓸 때
    * 현황 파악 오류
      * 중간 수행 결과를 다른 트랜잭션이 참조
    * 모순성
      * 일관성 결여(동시 실행)
    * 연쇄 복귀(Cascading Rollback)
      * 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류
* 병행 제어 기법
  * 로킹
    * 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보 장ㅎ나는 직렬화 기법
    * 로킹 단위 : 데이터베이스, 파일, 레코드
    * 로킹 단위가 작아지면 데이터베이스 공유도가 증가
    * 작아지면 오버헤드가 증가
    * 한꺼번의 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
  * 낙관적 검증
    * 어떠한 검증도 하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영
  * 타임 스탬프 순서
    * 실행을 시작하기 전에 갱신한 데이터에 대해 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행
  * 다중버전 동시성 제어
    * 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법
* 트랜잭션 상태
  * 활동 상태(Active)
    * 트랜잭션이 실행 중일 때
  * 부분 완료 상태(Partially Comitted)
    * 마지막 명령문이 실행된 후에 가지는 상태
  * 완료 상태
    * 성공적으로 완료
  * 실패 상태
    * 정상적인 실행이 더 이상 진행될 수 없을 때
  * 철회 상태(aborted)
    * 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작가 전 상태로 환원된 상태

### 테이블

* 필드들로 구성된 데이터의 집합체이다.
* 릴레이션 혹은 엔터티라고 부른다.
* 테이블에 포함된 행,열들 간에는 순서가 존재하지 않는다.

* 튜플은 릴레이션에서 같은 값을 가질 수 없음
* Cardinality : 튜플의 개수
* Degree : 차수(속성의 개수)
* **도메인 : 하나의 속성이 취할 수 있는 같은 원자값 들의 집합.**
* 옵티마이저 
  * 사용자가 질의한 SQL 문을 처리할 수 있는 실행 계획을 탐색하고 각 실행 계획에 대한 비용을 추정하여 최적의 실행계획을 수립하는 DBMS의 핵심 엔진이다.

### 뷰

* 논리 테이블로서 사용자에게 테이블과 동일하다.
* 뷰는 하나의 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있다.
* 뷰와 같은 결과를 만들기 위해 조인 기능을 사용할 수 있으나, 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있다.

* 뷰의 특징

  * 논리적 데이터 독립성 제공
    * 데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 접근 가능
  * 데이터 조작 연산 간소화
    * 앱이 원하는 논리적 구조를 형성하여 조작 연산 간소화
  * 보안 기능(접근 제어)
    * 특정 필드만을 선택해 뷰를 생성할 경우 앱은 선택되지 않은 필드의 조회 및 접근 불가
    * 보안 데이터를 저장하는 테이블에서는 보안 데이터를 제외하고 나머지 필드만 보여주는 뷰를 구성할 수 있다.
  * 뷰 변경 불가
    * 뷰 정의는 ALTER 문을 이용하여 변경할 수 없음

* 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있기 때문이다.

  ```sql
  SELECT * FROM 뷰이름;
  ```

  * 뷰 자체 인덱스 불가(인덱스는 물리적으로 저장된 데이터 대상)
  * 삽입, 삭제, 변경 제약

* 뷰 생성

```sql
CREATE VIEW 뷰_이름 컬럼_목록 AS 조회 쿼리
```

* SELECT 문에는 UNION이나 ORDER BY 절을 사용할 수 없다.

### INDEX

* 테이블에 대한 조회 속도를 높여 주는 자료구조다.

* 테이블의 특정 레코드 위치를 알려주는 용도로 사용한다.

* **인덱스는 자동으로 생성되지 않는다**

* 기본 키 컬럼은 자동으로 인덱스가 생성된다.

  ```SQL
  SELECT * FROM 사원 WHERE 이름 = '홍길동';
  ```

  

* '테이블의 이름' 컬럼에 인덱스가 없는 경우, 테이블으전체 내용을 검색한다.(Table Full Scan)

* 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있다.

* INDEX의 종류
  * 순서 인덱스
    * 데이터가 정렬된 순서로 생성되는 인덱스
    * B-Tree 알고리즘 활용(오름차순, 내림차순)
  * 해시 인덱스
    * 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
    * 데이터 접근 비용이 균일, Row 양에 무관
  * 비트맵 인덱스
    * 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스
    * 수정 변경이 적을 경우 유용(생년 월일 상품 번호 등)
  * 함수기반 인덱스
    * 수식이나 함수 적용
  * 단일 인덱스
    * 하나의 컬럼으로만 구성한 인덱스
    * 주 사용 컬럼이 하나일 경우
  * 결합 인덱스
    * 두 개 이상의 컬럼
    * WHERE 조건으로 사용하는 빈도가 높은 경우 사용
  * 클러스터드 인덱스
    * 기본 키 기준으로 레코드를 묶어서 저장하는 인덱스
    * 저장 데이터의 물리적 순서에 따라 인덱스 생성
    * 특정 범위 검색 시 유리

* 인덱스 생성

  ```SQL
  CREATE INDEX 인덱스명 ON 테이블명(컬럼명);
  ```

* 인덱스 삭제 명령시 테이블 변경 명령어가 사용된다.

  * 인덱스가 테이블의 종속 구조로 간주되기 떄문

* 인덱스 스캔 방식
  * 인덱스 범위 스캔
    * 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔
  * 인덱스 전체 스캔
    * 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지
  * 인덱스 단일 스캔
    * 수직적 탐색만으로 데이터 찾기
  * 인덱스 생략 스캔
    * 선두 컬럼이 조건 절에 빠졌어도 인덱스를 활용

### JOIN

* 논리적 조인
  * 사용자 SQL 문에 표현되는 테이블 결합 방식
    * 내부 조인
      * 공통 존재 컬럼의 값이 같은 경우
    * 외부 조인
      * 왼쪽
        * 왼쪽 테이블으모든 데이터와 오른쪽 테이블의 동일 데이터를 추출
      * 오른쪽
        * 오른쪽 모든 데이터
      * 완전
        * 양쪽의 모든 데이터
    * 교차 조인
      * 조인 조건이 없는 모 든 데이터 조합
    * 셀프 조인
      * 자기 자신에게 별칭 지정
* 물리적 조인
  * 데이터베이스 옵티마이저에 의해 내부적으로 발생하는 테이블 결합 방식
    * 중첩 반복 조인(Nested Loop)
      * 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방  Row를 결합하여 원하는 결과를 조합하는 조인 방식이다. 
      * 좁은 범위에 유리한 성능
      * 순차적으로 처리, **Random Access** 위주
      * 후행 테이블에는 조인을 위한 인덱스 생성이 필요하다.
      * 실행속도 = 선행 테이블 사이즈 * 후행 테이블 접근 횟수
    * 정렬 합병 조인(Sort -Merge Join)
      * 조인 대상의 범위가 넓을 경우 발생하는 임의 접근을 줄이기 위한 경우
      * 연결고리에 마땅한 인덱스가 존재하지 않을 경우
      * 양쪽 테이블의 정렬 결과를 차례대로 검색하면서 연결고리 형태로 합병
      * 랜덤 액세스 x 스캔
      * 선행집합 개념이 없다.
      * 정렬을 위한 영역에 따라 효율에 큰 차이가 발생한다.
      * 조인 연산자가 '='이 아닌 경우 중첩 반복 조인보다 유리한 경우가 많다.
    * 해시 조인
      * 해싱 함수를 활용하여 테이블 간 조인을 수행
      * 해싱 함수는 직접적인 연결이 아닌 연결될대상을 특정 지역에 모아두는 역할
      * 비용기반 옵티마이저에서만 가능, CPU 성능 의존적
        * 처리 방법에 대한 비용들을 산정해보고, 그중 가장 적인 비용이 들어가는 처리방법을 선택하는 옵티마이저
      * 해시 테이블 생성후 중첩 반복 조인처럼 순차적인 형태로 수행한다.

### 서브쿼리

* 메인쿼리와 서브쿼리 관계는 주종관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인 쿼리에 컬럼 정보를 사용할 수 있으나 역으로는 성립되지 않는다.
* 단일 행 서브쿼리
  * 결과가 항상 1건 이하인 서브쿼리
  * 단일 행 비교 연산자(=,<= 등) 사용
* 다중 행 서브쿼리
  * 실행 결과가 여러 건인 서브쿼리
  * 다중 행 비교 연산자 사용
  * IN
    * 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건
  * ALL
    * 서브쿼리의 결과에 모든 값을 만족
  * ANY
    * 결과에 어느 하나의 값이라도 만족
  * EXIST
    * 존재 여부 확인
* 다중 컬럼 서브쿼리
  * 메인 쿼리의 조건 절에 여러 컬럼을 동시에 비교할 떄
  * 서브쿼리와 메인 쿼리에서 비교하는 컬럼 개수와 위치가 동일해야함
* SELECT 절에 오는 서브쿼리는 반드시 단일 행을 리턴해야 함.
  * SUM, COUNT, MIN, MAX 과 같은 집계 함수와 많이 쓰임

# 논리적 데이터베이스 설계

## 관계 데이터베이스 모델

* 관계 데이터 모델 개념
  * 실세계 데이터를 테이블 형태로 구성된 데이터 모델이다.
* 릴레이션
  * 행과 열로 구성된 테이블
* 인스턴스
  * 정의된 스키마에 따라 생성된 테이블에 실제 저장된 데이터의 집합
* 스키마
  * 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조

### 관계 대수

* 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하고, 관계로 표현된 데이터를 취급하는 대수적인 연산 체계이자 절차적 정형 언어이다.
* 일반 집합 연산자
  * Cartesian Product
    * R X S
    * R과 S과 속한 모든 튜플을 연결해 만들어진 새로운 튜플로 릴레이션 구성
    * 새로운 차수 : 두 차수를 더한 값
    * 새로운 튜플의 수 : 두 차수를 곱한 ㄱ밧
* 순수 관계 연산자
  * 셀렉트(오메가)
    * 릴레이션 R에서 조건을 만족하는 튜플 반환
  * 프로젝트(파이)
    * 릴레이션 R에서 주어진 속성들으값만 구성된 튜플 반환
  * 조인(X)
    * 공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어지 튜플 반환
  * 디비전(나누기)
    * 릴레이션 S의 모든 튜플과 관련 있는 R의 튜플 반환
* 시스템 카탈로그
  * DB에 대한 메타 데이터
  * 일반 사용자도 검색할 수 있다.
  * 하지만 수정할 수는 없다.(DBMS가 스스로 유지)

### 데이터 모델링 및 설계

* 데이터 모델
  * 현실 세계의 정보 -> 인간과 컴퓨터가 이해할 수 있도록 추상화
  * 개념적 -> 논리적 -> 물리적

* 개념적 데이터 모델
  * 트랜잭션 모델링, View 통합 방법 및 Attribute 합성 고려
  * DB 종류와 관계 없음
  * 개체관계 다이어그램 (ERD)
* 논리적 데이터 모델
  * 업무의 모습을 모델링 기법으로 형상화하여 사람들이 이해하기 쉽게 표현
  * 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델, 객체지향 데이터 모델, 객체-관계 데이터 모델 중 하나에 맞게 설계
  * 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계
  * **정규화**
  * 논리적 데이터베이스 구조로 Mapping
  * 스키마의 평가 및 정제
* 물리적 데이터 모델
  * 논리 데이터 모델을 특정 DBMS의 특정 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 모델
  * DBMS의 특성을 고려하여 저장 구조로 변환
  * 테이블, 인덱스, 뷰, 파티션 등 객체를 생성
  * 응답시간, 저장 공간의 효율화 트랜잭션 처리를 고려한 설계
  * 반 정규화
    * 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행
  * 레코드 집중의 분석 및 설계
  * 저장 레코드 양식 설계
  * 접근 경로 설계

* 개체 관계 모델
  * 사람이 이해할 수 있는 형태

### 데이터베이스 정규화

* 중복 제거
  * 중복  예시 : 여러 개의 테이블에 나이, 주민등록번호 칼럼이 동시에 존재 -> 업데이트 발생할 때 다 같이 업데이트 해야 함.
* 수정, 삭제 시 이상현상 최소화
* 어떠한 릴레이션이라도 표현 가능하게
* 데이터 삽입 시에 릴레이션 재구성 필요성 줄이기
* 효과적인 검색 알고리즘 생성

* 이상 현상(Anomaly)

  * 릴레이션 조작 시 데이터가 불필요하게 중복
  * 삽입, 삭제, 갱신 이상

* 데이터베이스 정규화 단계

  * 1정규형

    1. 원자 값으로 구성

    1. 반복 속성/중복 제거 필요
       1. 이메일 주소가 속성에 2개 이상 있는 경우 원자값이 아니기 때문에 속성 1개만 가지도록 저장

  * 2정규형

    1. 부분 함수 종속 제거(완전 함수적 종속 관계)

    1. 어떤 컬럼이 어떤 컬럼을 영향(종속)을 주는가
       1. 고객명과 서비스이름이 서비스 이용 기간에 영향을 준다.
          1. 서비스 이름이 서비스 가격에 영향을 준다.
          2. 두 관계를 분리시켜야 한다.

  * 3정규형(현업은 여기까지만 수행)
    1. 이행 함수 종속 제거
       1. 책번호 -> 출판사 -> 홈페이지 (부분 함수 종속성)
       2. 책번호 -> 홈페이지 (이행 함수 종속성)

  * 보이스-코드 정규형(BCNF)
    1. 결정자가 후보 키가 아닌 함수 종속 제거
       1. 영향을 주는 관계가 후보 키가 아닐 경우
       2. 교수명이 과목명에 영향을 주는데 교수명은 학번 + 과목명에 영향을 받고 키가 아닐 경우

  * 4정규형
    1. 다중 값 종속성 제거
       1. 개발자-> (여러) 자격증 / 개발자 -> (여러)언어
       2. 각 관계 분리
  * 5정규형
    * 조인 종속성 제거
    * 개발자 -> 자격증 / 자격증 -> 언어 / 개발자 -> 언어

### 논리 데이터 모델 품질 검증

# 물리 데이터베이스 설계

## 스토리지

* 데이터를 보존하고 가능한 한 간편하게 액세스 할 수 있도록 개발된 기술을 사용하여 정보를 보존하는 저장장치를 의미한다.
* DAS(Direct Attached Storage)
  * 데이터 서버와 외장형 저장장치를 전용 케이블로 직접 접속하는 방법이다.
  * 주어진 성능이 보장, 안정성
  * 저장장치에 따른 접속 방법이 상이하여 저장장치 공유에 문제가 있음
* NAS(Network Attached Storage)
  * LAN을 통해 스토리지와 서버를 접속
  * 파일 서버를 통한 파일 시스템 공유
  * 데이터 저장 장치와 서버 간의 독립성 유지
  * 데이터 접근 요청에 의한 파일 서버의 병목 현상 발생 가능
  * 파일 서버 종료 시 스토리지 접근이 불가능
* SAN(Storage Area Network)
  * 광섬유 채널을 통하여 스토리지 연결
    * 기가비트 속도를 처리하는 장치
    * DAS의 접속 한계성을 극복
      * n개의 서버가 m개의 저장장치 접속 가능
    * 이기종 서버 환경을 지원하지 않음
    * 공유 가능한 파일 시스템과 데이터 형식이 제한

### 분산 데이터베이스

* 네트워크 상에서 여러 컴퓨터에 물리적으로 분산되어 있으나, 하나의 데이터베이스처럼 인식하도록 논리적으로 통합된 데이터베이스

* 장점

  * 분산 제어 용이
  * 지역 자치성 높음(원격 데이터 처리 센터 의존성 낮음)
  * 효용성과 융통성
  * 사용자 측면에서는 향상된 성능
  * 데이터 유실 복구 효과적
  * 확장 용이

* 단점

  * 복잡성 증가(설계 및 소프트웨어 개발 비용 증가)
  * 성능 저하(분산 데이터베이스간 메시지 교환 등으로 인한 오버헤드)
  * 개발 비용 증가

* 구성

  * 전역 스키마
    * 데이터베이스가 마치 분산되어 있지 않은 것처럼 분산 데이터베이스에 포함된 모든 데이터를 정의

  * 분할 스키마
    * 분산을 위해 단편화된 구성에 대한 정의(일대 다)
  * 할당 스키마
    * 단편들의 위치 정보를 정의
    * 중복 / 비중복 결정
  * 지역 스키마
    * 물리적 이미지를 해당 지역 DBMS가 관리할 수 있도록 저장하기 위해 변환

* 투명성

  * 위치
    * 사용자나 응용 프로그램이 접근할 데이터의 물리적 위치 알아야할 필요 X
  * 복제
    * 물리적으로 여러 곳에 복제되어있는지 알 필요 X
  * 병행(Concurrency)
    * 여러 사용자나 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 발생하지 않는 성질
  * 분할 투명성
    * 하나의 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 저장되어 있음을 알 필요가 없음
  * 장애 투명성
    * 통신망에 장애가 생겨도 데이터의 무결성 보존
    * 2 Phase Commit

### 데이터베이스 이중화

* 물리적으로 떨어져 있는 여러 개의 데이터베이스에 대하여 로컬 데이터베이스의 변경된 내용을 원격 데이터베이스에 복제하고 관리하는 기술이다.
* 액티브-액티브
  * 여러 노드가 동시에 가동되는 형태
  * 성능 좋음
* 액티브 - 스탠바이
  * 하나의 노드만 가동하고, 나머지 노드들은 대기하는 상태

### 데이터베이스 암호화

* 데이터베이스에 저장된 데이터를 읽기 어려운 값으로 변환.
* 유형
  * 응용 프로그램 자체 암호화
    * 암, 복호화 모듈이 API 라이브러리 형태로 각 애플리케이션 서버에 설치되고, 응용 프로그램에서 해당 모듈을 호출하는 방식
  * DB 서버 암호화
    * 모듈이 DB 서버에 설치
  * DBMS 자체 암호화
    * DBMS 커널이 자체적으로 암*복호화 기능
  * DBMS 암호화 기능 호출
    * 응용 프로그램에서 DB 서버의 DBMS 커널이 제공하는 암*복호화 방식 호출
  * 운영체제 암호화
    *  OS에서 발생하는 물리적인 입출력을 이용한 암 * 복호화 방식

* 적용 방식
  * 컬럼 암호화
    * 테이블에서 특정 컬럼 암호화
    * API
      * 암 복호화 모듈 애플리케이션 서버 내에 설치하고 이곳에서 수행
    * 플러그 인
      * 암 복호화 모듈을 DB 서버 내에 설치
    * 하이브리드
      * 배치 업무의 성능 저하를 보안하기 위해 API 방식 이용
  * 블록 암호화
    * DB, OS 자체적으로 블록 단위로 암호화
    * TDE 방식
      * DBMS에 추가 기능으로 제공되는 암호화 기능 이용하여 DB 내부에서 데이터 파일 저장 시 암호화
      * 파일에 저장된 내용을 메모리 영역으로 가져올 때 DBMS에 의해 자동으로 복호화
    * 파일 암호화
      * OS 상에서 확인 가능한 개체인 파일을 암호화하는 방식

### 접근 제어

* 불법적인 데이터 접근으로부터 보호
* 접근 권한을 가진 사용자가 권한을 남용하여 유출하거나 변조가 가장 큰 위험이다.
* 구성 요소
  * 접근제어 정책
    * 접근 모드 및 모든 접근 제한 조건 정의
    * 신원 기반 접근 제어 정책
      * Discrectionary Access Control
      * IBP(Individual Based Policy)
        * 단일 사용자가 하나의 객체에 대해 허가를 부여받아 사용
      * GBP(Group)
        * 복수 사용자가 하나의 객체에 대하여 같은 허가를 받아 사용
    * 규칙 기반 접근제어 정책
      * 객체에 포함된 정보의 비밀성과 이러한 비밀성의 접근정보에 대하여 주체가 갖는 권한에 근거하여 객체에 대한 접근 제한
      * Mandatory Access Control
      * MLP(Multi - Level)
        * 사용자 및 객체가 각각 부여된 기밀분류에 따른 정책
      * CBP(Compartment - based)
        * 조직 내 특정 집단 별로 구분된 기밀 허가
    * 역할 기반 접근 제어 정책
      * 중앙 관리자가 주체와 객체의 상호 관계 제어 조직 내에서 맡은 역할에 기초하여 자원에 대한 접근 허용 여부
      * Role based
  * 접근제어 메커니즘
    * 시도된 접근 요청을 정의된 규칙에 대응시켜 검사
    * ACL(Access Control List)
      * 주체가 디렉토리나 파일과 같은 특정 시스템 객체에 접근할 수 있는 허가 받은 접근 종류들이 기록된 목록
      * 주체가 객체에 어떤 행위를 할 수 있는지 표현
    * CL(Capabitlity list)
      * 주체에게 허가된 자원 및 권한의 목록
  * 접근제어 보안 모델
    * 요구 명세로부터 출발하여 기능적 모델 구현
    * 접근 제어 행렬
      * 임의적 접근 제어 관리 모델
      * 행은 주체 열은 객체
      * 행과 열은 주체 및 객체의 권한 유형을 표시
    * 기밀성 모델
      * 일반적인 사용 환경에서는 기밀성보다는 무결성이 중요하여 부적합
      * 벨라파듈라모델
      * Top Secret > Secret > Confidential > Unclassifed
    * 무결성 모델
      * 정보의 일방향 흐름 제어 활용 시
      * 주체와 객체의 보안 등급을 기반으로 하면서 제약 조건 역시 적용
      * 비바 모델
      * 클락윌슨 모델

## DB 물리 속성 설계

### 파티셔닝

* 대용량의 테이블을 파티션이라는 보다 작은 논리적인 단위로 나누는 것.
* 부하를 각각 파티션으로 분산
* 레인지 파티셔닝
  * 분할 키 값이 범위 내에 있는지 여부로 구분
* 해시 파티셔닝
  * 해시 함수의 값에 따라 파티션에 포함할 지 여부
* 리스트 파티셔닝
  * 값 목록에 파티션을 할당하고 분할 키 값을 그 목록에 비추어
* 컴포시트 파티셔닝
  * 2개 이상의 파티셔닝 결합

### 클러스터링

* 지정된 컬럼 값의 순서대로 데이터 행을 저장
* 하나 또는 그 이상의 테이블을 같은 클러스터 내 저장이 가능하다.
* 물리적 방법, 검색 효율을 높여주나 입력, 수정 , 삭제 시 부하
* 분포도가 넓을 수록 유리
  * 분포도 : 전체에서 선택했을 때 얼마만큼 자주 선택되어지느냐
  * PK : 분포도가 매우 낮다(하나만 존재)
* 단일 클러스터링
  * 클러스터에 하나의 테이블만 생성
  * 같은 클러스터 값을 가진 행은 같은 장소에 저장
* 다중 클러스터링
  * 단일 클러스터에 두 개의 이상의 테이블을 함께 저장
  * 같은 클러스터 키 컬럼을 가진 각 테이블의 롱는 정해진 장소에 같이 저장
  * 클러스터 컬럼이 수정되면 데이터 값이 수정되므로 추가적인 체인 블록이 발생하여 효율 감소
* 클러스터 고려사항
  * 대량의 범위를 자주 액세스 하는 경우
  * 인덱스를 사용한 처리 부담이 넓은 분포도
  * 여러 개의 테이블이 자주 조인을 일으킬 때
  * 반복 컬럼이 정규화에 의해 어쩔수 없이 분할된 경우
  * UNION, DISTINCT, ORDER BY, GROUP BY 빈번한 컬럼
  * 수정이 자주 발생하지 않는 컬럼

### 데이터 지역화

* 필요한 위치에 가까이 데이터를 배치
* 시간적 지역화
  * 최근에 참조된 기억 장소가 가까운 장래에 계속 참조될 가능성이 높은 특성
    *  for while 반복문에서 사용하는 조건 변수
* 공간적 지역화
  * 최근에 참조된 기억장소와 가까운 기억정보가 계속 참조
    * 배열에 연속 접근
* 순차적 지역화
  * 별도의 분기가 없는 한 데이터가 기억장치에 저장된 순서대로 순차적으로 인출되고 실행
    * 일대일, 일대다, 다대다 관계
* 기억장치 계층 구조
  * CPU -> 캐시 메모리 -> 메인 메모리 순으로 접근 시간 단축
* 캐시 접근 시간 단축
  * 캐시 적중률의 극대화 기능
  * LRU(Leasted Recently Used) 교체 방식
  * Pre-Fetch(선인출)
    * 필요한 정보와 예상 정보를 미리 인출하는 배치 방식
* 작업 세트
  * 하나의 Page가 자주 접근하는 페이지들으 집합.

## 물리적 데이터베이스 모델링

### 데이터베이스 무결성(Database Integrity)

* 데이터를 인가되지 않은 방법으로 변경할 수 없도록 보호
* 데이터에 적용되는 연산에 제한을 두어 유지
* 권한이 있는 사용자로부터 데이터베이스를 보호
* 종류
  * 개체 무결성
    * 한 엔터티에서 같은 기본 키를 가질 수 없거나, 기본 키 속성이 NULL을 허용할 수 없음
    * 기본 키, Unique Index
  * 참조 무결성
    * 외래 키가 참조하는 다른 개체의 기본 키에 해당되는 값이 기본 키 값이거나 NULL 이어야 함
    * Foreign key
  * 속성 무결성
    * 속성의 값은 기본값,  NULL 여부, 도메인(데이터 타입, 길이)이 지정된 규칙을 준수해야 함
    * CHECK NULL / NOT NULL DEFAULT
  * 사용자 무결성
    * 사용자의 의미적 요구사항을 준수해야 함
    * Trigger, User Defined Data Type
  * 키 무결성
    * 한 릴레이션에 같은 키 값을 같인 튜플들을 허용할 수 없음
    * Unique

### 컬럼 속성

* 구성요소
  * 내장 데이터 형식
    * 문자, 숫자, 시간, 대형 객체 등
  * 확장 데이터 형식
    * 행, 컬렉션, 사용자 정의 데이터 형식 등
* 고려사항
  * 타입에 따른 물리적 순서 조정
    * 고정 길이 컬럼이고 NOT NULL인 컬럼은 앞편에 정의
    * 가변 길이 컬럼은 뒤편에
    * NULL 값이 많을 것으로 예상되면 뒤편에
  * DBMS 물리적 순서조정 특성
    * 값이 변경될 때 체인 발생을 억제하고 저장 공간의 효율적인 사용을 위해 필요
  * 데이터 타입, 길이 조정 고려
    * 가변 길이 -> 예상되는 최대 길이
    * 고정 길이 -> 최소 길이로
    * 소수점 이하 자리 수의 정의는 반올림되어 자장되므로 정확성을 확인하고 정의
  * 비교 연산에서 두 데이터 타입과 같은 길이를 사용

### 키

* 조건을 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 기준이 되는 속성이다.
* 특성
  * 유일성
  * 최소성
    * 최소한의 속성으로 식별자 구성
* 종류
  * 기본 키
    * 테이블의 각 튜플들을 고유하게 식별하는 컬럼
  * 대체 키
    * 후보 키 중에서 기본키로 선택되지 않은 키
  * 후보 키
    * 테이블에서 각 튜플들을 구분하는데 기준이 되는 컬럼
    * 기본키 + 대체 키
  * 슈퍼 키
    * 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못하는 키
  * 외래 키
    * 테이블 간의 참조 데이터 무결성을 위한 제약 조건
    * 한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키

## 반 정규화

* 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다.
* 비정규화, 역정규화라고도 부른다.
* 성능 향상과 관리의 효율성
* 일관성 및 정합성 저하
* 유지를 위한 비용이 별도로 발생
* 기법
  * 테이블
    * 테이블 병합
      * 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능 향상
      * 슈퍼타입/ 서브타입 테이블 통합 통해 성능 향상
    * 테이블 분할
      * 수직 분할
        * 레코드를 기준으로 분할
      * 컬럼의 개수가 증가하는 경우 활용
        * 갱신 위주의 속성 분할
        * 자주 조회되는 속성 분할
        * 크기가 큰 속성 분할
        * 보안을 적용해야 하는 속성 분할
    * 중복 테이블 추가
      * 별도의 통계 테이블을 두거나 중복 테이블을 추가
      * 집계 테이블
        * 각 원본 테이블에 트리거를 설정하여 집계 테이블을 위한 테이블 생성
      * 진행 테이블
        * 이력 관리 등의 목적
        * 적절한 데이터야 ㅇ유지 및 활용도 
      * 특정 부분만 포함
        * 데이터가 많은 특정 부분만을 사용하는 경우
  * 컬럼
    * 컬럼 중복화
      * 조인 성능 향상을 위해
  * 관계
    * 중복 관계 추가
      * 여러 경로를 거쳐 조인이 가능하지만 발생할 수 있는 성능 저하를 예방하기 위해 추가적 관계

### CRUD 매트릭스

* 프로세스와 데이터 사이에 관계 의존성을 CRUD로 표현한 매트릭스이다.
* 구성 요 소
  * 엔터티 타입
    * 프로세스에 영향을 받는 데이터(DB의 튜플)
    * 고객, 제품, 주문, 목록
  * 단위 프로세스
    * 엔터티에 영향을 주는 업무 단위
    * 데이터베이스의 트랜잭션 역할
    * 고객 등록, 주문 조회
  * CRUD
    * 프로세스가 엔터티에 주는 영향
    * 생성, 조회, 수정, 삭제
* 매트릭스 규 칙
  * 엔터티 타입
    * 모든 엔터티에 C가 존재
      * 데이터는 1번 생성되어야 함
      * 데이터 생성이 데이터의RUD 불가능
    * 모든 엔터티에 R이 존재
      * 데이터는 최소한 1번은 읽어야함
    * 모든 엔터티에 CRUD 존재
      * CRUD 중 하나라도 존재해야 함
  * 프로세스
    * 두 개 이상의 단위 프로세스가 하나의 엔터티 타입 생성 불가
      * 같은 엔터티에 두 개 이상의 C가 존재하면 안 됨
    * 모든 단위 프로세스는 하나 이상의 엔터티를 표기

### SQL 성능 튜닝

* 옵티마이저 조정
* 힌트 사용
  * 힌트를 사용해 원하는 실행 계획으로 유도
* 부분 범위 처리 사용
  * 일부만 액세스한 후 결과를 리턴
* 인덱스 활용

### ETL

* 원천 시스템에서 데이터를 추출하여 변환 작업을 거쳐 목적 시스템으로 적재하는 프로세스이다.

### 파일 처리 기술

* 많은 양의 자료를 각종 매체에 저장.

* 유형
  * 순차 파일
    * 입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록
    * 변동 사항이 크지 않고 기간별로 일괄 처리를 주로 하는 경우에 적합
    * 자기 테이프에서 사용
    * 데이터 검색 시 순차 검색으로 인한 효율성 저하
    * 매체 변환 용이
  * 색인 순차 파일
    * 레코드들을 Key 값 순으로 정렬
    * 순차 처리와 랜덤 처리 가능
    * 색인을 이용한 순차적인 접근
    * 색인 탐색 후 색인이 가리키는 포인터를 사용하여 직접 참조
    * CRUD 용인
    * 색인에 대한 추가 공간 필요
  * 직접 파일
    * 특정 순서 없이 임의의 물리적 저장 공간에 기록
    * Random File
    * 해시 함수에 의해 계산된 물리적 주소를 통해 접근
    * 평균 접근시간 내 접근 ㄱ나ㅡㅇ
    * 주소 변환 과정에 필요로 하는 시간
    * 별도의 기억 공간 확보 필요



