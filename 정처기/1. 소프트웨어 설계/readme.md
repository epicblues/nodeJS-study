## Key

- 요구사항 분석
- 소프트웨어 아키텍처
- 객체지향
- 객체
- 디자인 패턴
  - 객체지향 프로그래밍 설계를 할 때 자주 발생하는 문제를 피하기 위해 사용
- 인터페이스
  - 서로 다른 두 시스템, 장치, 소프트웨어를 서로 이어주는 접속 및 중계시스템이다.

# 요구사항 확인

## 플랫폼 기능 분석

### 1. 플랫폼의 개념

- 플랫폼은 애플리케이션을 구동시키는 데 필요한 소프트웨어의 환경이다.
- 동일 플랫폼 내에서는 상호 호환이 가능하도록 만들어진 결합체를 의미한다.
- 공급자와 수요자 등 복수 그룹이 참여하여 각 그룹이 얻고자 하는 가치를 공정한 거래를 통해 교환할 수 있도록 구축된 환경이다.

### 2. 플랫폼의 유형

| 유형               | 설명                                             | 사례                      |
| ------------------ | ------------------------------------------------ | ------------------------- |
| 싱글 사이드 플랫폼 | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태 | 아이튠즈, 안드로이드 마켓 |
| 투 사이드 플랫폼   | 두 그룹을 중개하고 모두에게 개방하는 형태        | 소개팅 앱                 |
| 멀티 사이드 플랫폼 | 다양한 이해관계 그룹을 연결하여 중개하는 형태    | 페이스북 인스타그램       |

### 3. 플랫폼의 기능

- 소프트웨어개발과 운영비용이 감소하고 생산성이 향상된다.
- 동일 플랫폼의 커뮤니티를 형성하고 **네트워크 효과**를 유발한다.
  - 네트워크 효과
    - 어떤 상품에 대한 수요가 형성되면 이것이 다른 사람들의 상품 선택에 큰 영향을 미치는 현상이다.

### 4. 플랫폼 기능 분석 절차

| 순서 | 절차                  | 설명                                                                                                          |
| ---- | --------------------- | ------------------------------------------------------------------------------------------------------------- |
| 1    | 현행 플랫폼 자료 수집 | _ 현행 시스템 담당자 제시 자료와 인터뷰를 통해 자료 수집 / 파악<br/> _ 인터뷰 결과서, 현행 플랫폼 구성도 도출 |
| 2    | 수집 자료 분석        | \* 수집된 자료에 산발적으로 존재하는 정보들의 취합/ 정제 작업을 실시                                          |
| 3    | 결과 산출물 작성      | \* 수집된 자료를 기반으로 플랫폼 기능분석도 작성                                                              |

## 플랫폼 성능 특성 분석

### 1. 플랫폼 성능 특성 분석 이유

- 플랫폼 성능 분석을 통해 사용자의 서비스 이용 시 속도의 적정성을 알 수 있다.
- 사용자 요구사항 중 성능에 대한 개선요청 항목은 현재 시스템 플랫폼 성능이 느린 것으로 제기될 가능성이 높다.

### 2. 플랫폼 성능 분석 기법

| 기법          | 설명                                                 | 산출물                          |
| ------------- | ---------------------------------------------------- | ------------------------------- |
| 사용자 인터뷰 | 현행 플랫폼 사용자 인터뷰를 통해 속도의 적정성 확인  | 인터뷰 결과서                   |
| 성능 테스트   | 현행 플랫폼을 대상으로 성능, 부하 테스트를 수행      | 성능 테스트, 부하 테스트 결과서 |
| 산출물 점검   | 현행 플랫폼과 유사한 타사 제품의 성능 자료 등을 분석 | **벤치마킹 테스트** 결과서      |

- 벤치마킹 테스트 : 도입하려는 제품군의 대상 Vendor를 설정하여 해당 제품군의 성능을 비교하는 테스트이다.

### 3. 플랫폼 성능 특성 측정 항목

| 측정 항목                  | 설명                                                                    |
| -------------------------- | ----------------------------------------------------------------------- |
| 경과 시간(Turnaround Time) | 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간    |
| 사용률                     | 애플리케이션이 의뢰한 작업을 처리하는 동안 CPU, 메모리 등의 자원 사용률 |
| 응답 시간                  | 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 떄까지 걸린 시간    |
| 가용성                     | 일정 시간 내에 애플리케이션이 처리하는 일의 양                          |

## 운영체제 분석

### 1. 운영체제의 개념

- 운영체제는 하드웨어및 소프트웨어 자원을 효율적으로 관리하며 공통된 기능을 제공하는 소프트웨어이다.
- 사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 소프트웨어이다.

### 2. 운영체제 현행 시스템 분석

#### 품질 측면

- 신뢰도
  - 장기간 시스템 운영 시 운영체제의 장애 발생가능성
  - 운영체제의 버그로 인한 재기동 여부
- 성능
  - 대규모 및 대량 파일 작업(배치 작업)처리
    - **Batch Job** : 실시간 작업의 반대 개념으로 일련의 작업들을 하나의 작업 단위로 묶어서 일괄로 처리하는 작업이다.
  - 지원 가능한 메모리 크기(32bit, 64bit)

#### 지원 측면

- 기술 지원
  - 공급사들의 안정적인 기술 지원
  - 오픈 소스 여부
- 주변 기기
  - 설치 가능한 하드웨어
  - 다수의 주변 기기 지원 여부
- 구축 비용
  - 지원 가능한 하드웨어비용
  - 설치할 응용 프로그램의 라이선스 정책 및 비용
  - 유지 및 관리 비용

## 4, 네트워크의 분석

### 1. 네트워크의 개념

- 네트워크는 컴퓨터 장치들이 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환하는 기술이다.
- 데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이와 같은 무선 매체를 통해 성립된다.

### 네트워크 현행 시스템 분석

- 현행시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석한다.
- 네트워크 구성도의 작성을 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있다.
- **백본망**, **라우터**, **스위치**, **게이트웨이**, **방화벽** 등을 대상으로 분석한다.
  - 백본망(BackBone Network)
    - 다양한 네트워크를 상호 연결하는 컴퓨터 네트워크의 일부로서 각기 다른 LAN이나 부분망 간에 정보를 교환하기 위한 경로를 제공하는 망이다.
  - 라우터
    - 3계층 데이터 패킷을 발신지에서 목적지까지 전달하기 위해 최적의 경로를 지정하고, 이 경로를 따라 데이터 패킷을 다음 장치로 전달하는 네트워크 장비이다.
  - 스위치
    - 2계층 장비로서, 동일 네트워크 내에서 출발지에 들어온 데이터 프레임을 목적지 MAC 주소 기반으로 빠르게 전달하는 네트워크 장비이다.
  - 게이트웨이
    - 컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 네트워크 장비이다.
  - 방화벽
    - 외부로부터 불법 침입과 내부의 불법 정보 유출을 방지하고, 내/외부 네트워크의 상호 간 영향을 차단하기 위한 보안 시스템이다.
- 물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 쉽다.
- 네트워크 장애 발생 추적 및 대응 등의 다양한 용도로 활용할 수 있다.

## DBMS 분석

### 1. DBMS의 개념

- DBMS는 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램이다.

### 2. DBMS의 기능

| 기능            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 중복 제어       | 동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지      |
| 접근 통제       | 권한에 따라 데이터에 대한 접근 제어                          |
| 인터페이스 제공 | 사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공         |
| 관계 표현       | 서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공 |
| 샤딩/파티셔닝   | 구조 최적화를 위해 작은 단위로 나누는 기능 제공              |
| 무결성 제약조건 | 무결성에 관한 제약 조건을 정의/검사하는 기능 제공            |
| 백업 및 회복    | 데이터베이스 장애 발생 시 데이터의 보존 기능 제공            |

### 3. 데이터베이스 현행 시스템 분석

- 성능 측면
  - 가용성
    - 장기간 시스템을 운영할 때 장애 발생 가능성
    - 백업 및 복구 편의성
    - DBMS 이중화 및 복제 지원
  - 성능
    - 대규모 데이터 처리 성능
    - 대량 거래 처리 성능
    - 다양한 튜닝 옵션 지원 여부
    - 비용 기반 최적화 지원 및 설정의 최소화
  - 상호 호환성
    - 설치 가능한 운영체제 종류
    - 다양한 운영체제에서 지원되는 **JDBC**, **ODBC**
      - JDBC(Java Database Connectivity)
      - ODBC(_**Open**_ DataBase Connectivity)
- 지원 측면
  - 기술 지원
    - 공급 업체들의 안정적인 기술 지원
    - 다수의 사용자 간의 정보 공유
    - 오픈 소스 여부
  - 구축 비용
    - 라이선스 정책 및 비용
    - 유지 및 관리 비용

## 비즈니스 융합 분석

- 비즈니스 융합은 융합 기술이 제공하는 기회나 융합의 원리를 적용해서 새로운 제품, 서비스, 산업을 창출하거나 기존 제품을 혁신하기 위한 기업 활동이다.
- 스마트 팩토리
  - 기획/설계, 생산, 유통/판매 등 전 과정을 ICT 기술로 통합, 최소비용 및 시간으로 고객 맞춤형 제품을 생산하는 지능화된 공장이다.
- 옴니채널
  - 소비자가 온라인, 오프라인, 모바일 등 다양한 경로로 상품을 검색하고 구매할 수 있도록 하는 서비스이자, 각 유통 채널의 특성을 결합해 어떤 채널에서든 같은 매장을 이용하느 것처럼 느낄 수 있도록 한 쇼핑 환경이다.

# 요구사항 확인

## 요구분석 기법

### 1. 요구분석(Requirements Analysis)의 개념

- 요구분석은 도출된 요구사항 간 상충을 해결하고 소프트웨어의 범위를 파악하여 **외부 환경**과의 상호작용을 분석하는 과정이다.
  - 외부 환경 : 광의적인 측면에서 하드웨어, 소프트웨어, 네트워크 등의 환경이다.
  - 사용자가 인터넷 환경에서 큐넷 서버로 접근해서 기사시험 접수를 한다고 가정하면 사용자(**외부 환경**)와 큐넷 시스템의 상호작용을 분석한다. 여기서 요구사항은 기사시험을 정상적으로 접수하는 것.
- 요구분석은 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.

### 2. 요구분석의 특징

- 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있다.
- 보다 구체적인 명세를 위해 **소단위 명세서**가 활용될 수 있다.
- 개발 비용이 가장 많이 소요되는 단계는 <U>**아니다**</U>

### 3. 요구분석 기법

1. 요구사항 분류

   - 요구사항이 기능인지 비 기능인지 확인
   - 요구사항이 소프트웨어에 미치는 영향의 범위를 파악
   - 요구사항이 소프트웨어 생명주기 동안 변경이 발생하는지를 확인
   - 하나 이상의 상위 요구사항에서 유도된 것인지 또는 이해관계자나 다른 원천으로부터 직접 발생한 것인지 분류

2. 개념 모델링 생성 및 분석

   - 모델 : 요구사항을 더 쉽게 이해할 수 있도록 상황을 단순화, 개념적으로 표현한 것.
   - 모델링 표기는 주로 UML을 사용

3. 요구사항 할당

   - 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
   - 다른 구성요소와 어떻게 상호작용하는지 분석 -> 추가적인 요구 사항 발견 가능

4. 요구사항 협상

   - 두 명의 이해관계자가 서로 상충되는 내용을 요구하는 경우, 적절한 지점에서 합의하기 위한 기법
   - 충돌할 떄 요구 사항의 우선순위를 각각 부여하면 무엇이 더 중요한지 인식 가능

5. 정형 분석

   - 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현
   - 구문(Syntax)과 의미(Semantics)를 갖는 정형화된 언어를 사용하여 수학적 기호로 표현
   - 마지막 단계

### UML : Unified Modeling Language

- 의존 관계
  - 사물과 사물 사이에 서로 연관은 있으나 필요에 따라 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현.
  - 사물의 변화가 다른 사물에도 영향을 미치는 관계

# 2. 화면 설계

## UI 개요

### 1. UI 개념

- 사용자 인터페이스는 넓은 의미에서 사용자와 시스템 사이에서 의사 소통할 수 있도록 고안된 물리적, 가상의 매개체이다.
- 좁은 의미로는 정보 기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면이다ㅌ
- UX(User Experience) : 제품과 시스템, 서비스 등을 사용자가 직, 간접적으로 경험하면서 느끼고 생각하는 총체적 경험
  - 사용과 맥락
    - 사회적 구조 및 과업
    - 애플리케이션 영역
    - 사용자와 기계 사이의 적응성
  - 사용자(UI)
    - 인간 정보처리 과정
    - 사회적 구조 및 과업
    - 인간공학적 요소
  - 컴퓨터(UI)
    - 입출력 장치
    - 상호작용 기술
    - 컴퓨터 그래픽스
    - 상호작용 구조

### UI 유형

|     유형     | 특징                               | 설명                                                                                                     |
| :----------: | ---------------------------------- | -------------------------------------------------------------------------------------------------------- |
|     CLI      | 정적인 텍스트 기반 인터페이스      | 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스                                                    |
|     GUI      | 그래픽 반응 기반 이터페이스        | 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스                                   |
| NUI(Natural) | 직관적 사용자 반응 기반 인터페이스 | 사용자가 가진 경험을 기반으로 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스                |
| OUI(Organic) | 유기적 상호작용 기반 인터페이스    | 입력장치가 곧 출력장치가 되고, 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스 |

### UI 설계 원칙

| 설계 원칙 |                                 설명                                  |                부특성                 |
| :-------: | :-------------------------------------------------------------------: | :-----------------------------------: |
|  직관성   |           누구나 쉽게 이해하고, 쉽게 사용하라 수 있어야 함            | 쉬운 검색<br/>쉬운 사용성<br/>일관성  |
|  유효성   |        정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작        |        쉬운 오류 처리 및 복구         |
|  학습성   |        초보자와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작         |     쉽게 학습 쉬운 접근 쉽게 기억     |
|  유연성   | 사용자의 **인터렉션**을 최대한 포용하고, 실수를 방지할 수 있도록 제작 | 오류 예방<br/>실수 포용<br/>오류 감지 |

### UI 시스템의 필요 기능

- 사용자의 입력을 검증한다.
- 에러 처리와 에러 메시지 처리를 한다.
- 도움과 프롬프트를 제공한다.

## UI 표준

- UI 표준은 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약이다.

|         UI 표준 구성          | 설명                                                                   |
| :---------------------------: | ---------------------------------------------------------------------- |
|       전체적인 UX 원칙        | 사용자의 관점에서 사용자 업무를 효율적으로 수행할 수 있는 UX 원칙 정의 |
|         정책 및 철학          | 조직의 목표나 정체성을 포함하는 정책 및 철학 설정                      |
|       UI 스타일 가이드        | UI에 대한 구동 환경 및 레이아웃 등을 정의                              |
|       UI 패턴 모델 정의       | **CRUD 방식**을 기반으로 데이터 입력, 출력 패턴 모델 정의              |
| UI 표준 수립을 위한 조직 구성 | UI 팀 및 표준 개발 팀을 주축으로 추진 조직 구성                        |

- 그리드 - 레이아웃을 격자 모양의 테이블 형태로 표현하는 방법

### UI 패턴 모델 정의

- CRUD 방식을 기반으로 하여 데이터의 입력과 출력을 처리하는 화면 흐름을 포함하여 오퍼레이션 방식에 대한 표준 절차를 표시하고, UI 패턴 모델을 개발한다.

#### 패턴 별 표준 개발 방법 정의

- 업무 화면 클라이언트 정의
  - 제안 단계에서 결정된 클라이언트를 통해 설계자는 개발 시에 필요한 공통 요소 식별, 디렉토리 구성, 개발 환경 구축 부분 도출
  - 클라이언트에 출력되는 UI는 X-Internet으로 대변되는 **리치 클라이언트**와 일반 JSP, HTML 기반의 **씬 클라이언트**가 존재
    - 리치 클라이언트 : SW의 실행을 클라이언트에서 책임지는 기술로 서버는 클라이언트에서 요청한 SW의 실행 코드를 스트림 혀 형태로 제공하고, 클라이언트는 서버로부터 스트리밍되는 SW 코드를 클라이언트 PC의 자원을 이용하여 실행하는 기술이다.
    - 씬 클라이언트 : 소프트웨어의 실행을 전적으로 서버에서 책임지는 기술. 서버에서 가상머신을 이용하여 클라이언트의 데이터와 소프트웨어를 관리 및 실행하는 기술이다.
- 서버 컨트롤러 정의
  - 프레임워크를 도입한다면 해당 프레임워크가 제공하는 방식 채택
  - 별도의 클라이언트 제품 도입하는 경우 서버 컨트롤러와의 연동 방식 결정
- 서버 메시지 및 예외 처리 정의
  - S(System)
    - 시스템 오류로 인해 발생하는 메시지
    - 런타임 예외를 전달할 떄 사용되며, 모든 트랜잭션은 자동으로 복원(Rollback)
  - E(Error)
    - 업무 처리 로직의 일환으로 애플리케이션 예외를 전달할 떄 사용
    - 모든 트랜잭션은 자동으로 복원
  - I(Information)
    - 정상적인 업무 처리나 결과나 정보에 대한 확인
    - 메시지를 사용자에게 알려주고자 할 떄 사용
    - 이때 모든 트랜잭션은 커밋(Commit) 됨.
- 클라이언트 - 서버 간 데이터 변환 정의
  - 어떤 방식의 Object를 사용할 것인지를 먼저 결정
  - 클라이언트와 서버 간의 데이터 형태 변환을 어떻게 처리할 것인지 방안 마련

### 스토리보드

- 스토리보드는 UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임, 기능에 대한 정의, 데이터베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서이다.
- UI 화면 설계를 위해서는 스토리보드, 와이어 프레임, 프로토타입이 활용된다.

| 구분         | 설명                                                                                                                        | 도구                                   |
| ------------ | --------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| 와이어프레임 | 이해관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업            | 파워포인트 / 키노트 / 스케치/ 일러스트 |
| 스토리보드   | 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터 베이스 연동 모든 정보가 담겨 있는 산출물                      | 파워포인트 / 키노트 / 스케치           |
| 프로토타입   | 정적인 화면으로 설계된 와이어프레임 또는 스토리보드에 동적 효과를 적용함으로써 실제 구현된 것처럼 시뮬레이션할 수 있는 모형 | HTML / CSS                             |
|              |                                                                                                                             |                                        |

스토리보드 작성 절차

    1. 전체 개요 작성
    1. 서비스 흐름 작성(어떤 버튼을 누르면 어떤 이벤트가 발생하는지, 다음 화면은 무엇인지, 어떤 서버와 통신하는지 등)
    1. 스타일 확정
    1. 메뉴별 화면 설계도 작성 및 상세설명
    1. 추가 관련 정보 작성

- Profile : 어떤 시스템을 일정 범위 내에서 한정적으로 특징 지우는 그룹화된 값이다.
- UI 컨셉션 : 정리된 요구사항을 구체화하는 단계로 **화면 디자인 단계 전**에 대표 화면 설계를 진행하는 단계

## UI 설계

### UI 설계 프로세스

1. 문제 정의
2. 사용자 모델 정의
3. 작업 분석
4. 컴퓨터 오브젝트 및 기능 정의
5. 사용자 인터페이스 정의(마우스, 키보드 등 컴퓨터와 상호 작용을 하는 오브젝트 선택)
6. 디자인 평가(GoalsOperatorsMethodsSelection, 휴리스틱(경험 기반 문제 해결 학습 발견))

### UI 흐름 설계

1. 화면에 표현되어야 할 기능 작성
2. 화면의 입력 요소 확인
3. UI 요구 사항을 기반으로 유스케이스 설계(액터별 시나리오 작성)
4. 기능 및 양식 확인

- 집적 회로(Integrated Circuit)
  - 하나의 반도체 기판에 다수의 능동소자(트랜지스터, 진공관 등)와 수동소자(저항, 콘덴서, 저항기 등)를 초소형으로 집적, 서로 분리될 수 없는 구조로 만든 완전한 회로기능을 갖춘 기능소자이다.
- 목업(Mockup)
  - 비용 절감 목적으로 실제 제품이 나오기 전 만드는 모형을 의미한다.
- 프로토타이핑은 실제 구현은 아니고 결과물에 대해 이해를 돕기 위해 수행하는 것

# 애플리케이션 설계

## 공통 모듈 설계

### 공통 모듈의 개념

- 모듈의 개념
  - 모듈은 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭하는 용어이다.
  - 모듈화를 통해 분리된 시스템의 기능들로 서브 프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용된다.
- 모듈의 특징
  - 각각의 모듈은 상대적으로 독립성을 가지고 있다.
  - 모듈 내부에는 그 모듈을 하나로 통합하는 수많은 조합이 존재할 수 있다.
  - 모듈은 **단독으로** 컴파일 할 수 있으며 재사용 할 수 있다.
  - 독립성이 높은 모듈일수록 모듈 수정 시에도 다른 모듈들에는 영향을 거의 미치지 않고, 오류가 발생 시에도 쉽게 해결할 수 있다.
  - 모듈의 독립성은 **결합도와 응집도**에 의해 측정되며, 독립성을 높이려면 모듈의 **결합도는 약하게**, **응집도는 강하게**, 모듈으 크기는 작게 만들어야 한다.
- 공통 모듈의 개념
  - 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미한다.
  - 자체적으로 **컴파일**가능하고 다른 프로그램에서 재사용 가능.
  - 여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈을 의미하며 날짜 처리를 위한 유틸리티 모듈 등이 해당된다.

### 모듈화

- 모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 소프트웨어제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법이다.

#### 모듈화 기법

| 기법      | 설명                                                                                                               |
| --------- | ------------------------------------------------------------------------------------------------------------------ |
| 루틴      | 소프트웨어에서 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임                                        |
| 메인 루틴 | 프로그램의 주요한 부분이며, 전체의 개략적인 동작 절차를 표시하도록 만들어진 루틴 <br/>메인 루틴은 서브 루틴을 호출 |
| 서브 루틴 | 메인 루틴에 의해 필요할 떄마다 호출되는 루틴                                                                       |

#### 모듈화 유형

- 응집도
  - 모듈 내부에서 구성요소 간에 밀접한 관계를 맺고 있는 정도
  - 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성
- 결합도
  - 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내는 정도
  - 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어짐

| 구분           | 팬인(Fan-In)                                                                                            | 팬아웃(Fan-Out)                             |
| -------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 개념           | 어떤 모듈을 제어(호출)하는 모듈의 수                                                                    | 어떤 모듈에 의해 제어되는 모듈의 수         |
| 모듈 숫자 계산 | 모듈 자신을 기준으로 모듈에 들어오면 팬인                                                               | 모듈 자신을 기준으로 모듈에서 나가면 팬아웃 |
| 고려사항       | 높을수록 재사용 측면에서 설계가 잘 된 것. 단일 장애점 발생 가능, 높을수록 관리 비용 및 테스트 비용 증가 | 불필요한 모듈 호출 검토 필요                |

## 설계 모델링

- 설계 모델링은 요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법이다.

### 설계 모델링 유형

- 구조 모델링
  - 소프트웨어를 구성하는 컴포넌트들의 유형, 인터페이스, 내부 설계 구조 및 이들의 상호 연결 구조를 모델링
  - 시스템의 구성요소들과 이들 사이의 구조적인 관계와 특성들을 모델링
  - 프로시저, 데이터 구조, 모듈, 파일 구조
    - 프로시저 : 프로그램을 기능에 따라 여러 개의 단위로 분해하여 작성하는 것으로 크게 서브 프로시저와 함수 프로시저로 나뉜다.
- 행위 모델링
  - 소프트웨어의 구성요소들의 기능들과 이들이 언제, 어떠한 순서로 기능을 수행하고 상호작용하는지를 모델링
  - 언제 어떠한 순서로 수행되는가와 같은 동적인 특성들을 모델링
    - 입력 데이터, 출력 데이터, 데이터 흐름, 데이터 변환, 데이터 저장 등

### 코드 설계

- 코드 설계는 데이터의 분류나 조합을 쉽게 하기 위하여 사물을 표현하는 코드를 설계하는 기법이다.

#### 코드의 기능

|   기능    | 설명                                                                    |
| :-------: | ----------------------------------------------------------------------- |
|  표준화   | 정보를 종류, 모양, 크기등의 일정한 기준에 따라 통일적으로 표현하는 기능 |
|   분류    | 정보들을 동일한 특성을 가진 데이터로 그룹화하여 나누는 기능             |
|   식별    | 다른 것과 구별될 수 있는 기능                                           |
|   배열    | 일련의 순서로 나열할 수 있는 기능                                       |
|  간소화   | 정보의 표현 간소화                                                      |
|   연상    | 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능     |
|  암호화   | 정보의 외부 표현을 감추고자 하는 기능                                   |
| 오류 검출 | 정보 입력이나 관리 시 잘못된 정보를 찾아내는 기능                       |

#### 코드 설계 종류

- 연상 코드
  - 코드만 보고 대상을 연상할 수 있도록 명칭 일부를 약호(간단하고 알기 쉽게 나타내어 만든 부호) 형태로 넣어 구성된 코드
  - ex ) 나라이름(KR, US)
- 블록 코드
  - 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 코드
  - 구분 코드라고 함
  - 전화번호에서 지역번호와 국번(같은 지역끼리 공통)
- 순차 코드
  - 일정한 기준에 따라 순서대로 일련번호를 부여한 코드
  - 중고등 학생들으반에서 번호(가나다순으로 1번 , 2번...)
- 표의 숫자 코드(Significant Digit Code)
  - 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등을 표시한 코드
- 그룹 분류식 코드
  - 대상을 기준에 따라 대분류, 중분류, 소분류로 구분하여 번호를 부여한 코드
  - 학번(입학 연도 - 일련번호)

### HIPO(Hierarchy Input Process Output)

- 하향식 소프트웨어 개발을 위한 문서화 도구

| 종류        | 설명                                                 |
| ----------- | ---------------------------------------------------- |
| 가시적 도표 | 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조도 |
| 총체적 도표 | 입력-처리-출력에 대한 정보를 제공하는 도표           |
| 세부적 도표 | 총체적 도표에 표시된 기능 상세히 기술                |

## 소프트웨어 아키텍처

- 소프트웨어 아키텍처는 여러 가지 소프트웨어 구성 요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조이다.
- 아키텍처는 시스템의 비기능적인 요소에 집중해서 만들어지고, 기능적인 요소도 구료한다.

#### 4 + 1 뷰

- 유스케이스 뷰
  - 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 사용자, 설계자, 개발자, 테스트 관점
- 논리 뷰
  - 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자, 개발자 관점
- 프로세스 뷰
  - 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자, 시스템 통합자 관점
- 구현 뷰
  - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
  - 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
- 배포 뷰
  - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

### 소프트웨어 아키텍처 패턴

- 계층화 패턴(Layered Pattern)

  - 시스템을 계층으로 구분하여 구성하는 패턴
  - 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공
  - 계층화 패턴은 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어짐

- 클라이언트 - 서버 패턴

  - 하나의 서버와 다수의 클라이언트
  - 서버는 계속 클라이언트로부터 요청을 대기

- 파이프 - 필터 패턴

  - 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능
  - 서브 시스템의 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
  - 필터 컴포넌트는 재사용성이 조혹, 추가가 쉽기 때문에 확장이 용이

- 브로커 패턴

  - 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴
  - 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행
  - 서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주며(Publish), 클라이언트가 브로커에 서비스르 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 Redirection함.

- 모델 - 뷰 - 컨트롤러 패턴

  - 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화하는 패턴

  - | 패턴     | 기능                               |
    | -------- | ---------------------------------- |
    | 모델     | 핵심 기능과 데이터 보관            |
    | 뷰       | 사용자에게 정보 표시               |
    | 컨트롤러 | 사용자로부터 요청을 입력 받앛 ㅓ리 |

  - 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행 가능

  - 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합.

## 객체지향 설계

- 클래스는 객체지향 프로그램에서 데이터를 **추상화**하는 단위이다.

- 객체의 행위(메서드)는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용
- 객체마다 각각의 상태와 식별성을 가짐
- 메시지

  - 객체 간 상호작용을 하기 위한 수단
  - 객체 간의 상호작용은 메시지를 통해 이루어짐
  - 메시지는 객체에서 객체로 전달됨

- 인스턴스
  - 객체지향 기법에서 클래스에 속한 각각의 객체
  - 실제로 메모리상에 할당

### 객체지향 기법

- 캡슐화
  - 서로 관련성이 많은 데이터와 이와 관련된 함수들을 한 묶음으로 처리하는 기법
  - 결합도가 낮아지고 재사용이 용이
  - 인터페이스가 단순화 됨
  - 정보은닉과 관계가 깊음
  - 변경 발생 시 오류의 파급 효과가 작음
- 상속성
  - 상위 클래스의 속성과 메소드를 하위 클래스에서 **재정의 없이** 물려받아 사용하는 기법
- 다형성
  - 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
  - **오버로딩**, **오버라이딩**이 대표적
    - 오버로딩 : 매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러 개 가지는 기법
    - 오버라이딩 : 자식 클래스가 부모 클래스의 메서드 재정의해서 사용
- 추상화
  - 공통 성질을 추출하여 추상 클래스를 설정하는 기법
  - 기능 추상화, 자료 추상호, 제어 추상화
- 정보은닉
  - 코드 내부 데이터와 메소드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술
  - Side-Effect를 최소화하기 위하여 사용
- 관계성
  - 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법
    - 연관화
      - is-member-of 관계
      - 클래스와 객체의 참조 및 이용관계
      - 같은 계층에 속하는 클래스들 사이의 상호 의존성을 보여주는 비계층적 관계성을 나타냄
    - 집단화
      - is part of 관계, part-whole 관계
      - 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 특징
      - 일반화와 달리 상위 클래스의 성질들이 하위 클래스로 상속되지는 않음
    - 분류화
      - is-instance-of
      - 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스
    - 일반화
      - is-a 관계
        - 클래스들 간의 개념적인 포함 관계
        - 상위 클래스의 특성을 하위 클래스가 상속받음
    - 특수화
      - is-a 관계
        - 상위 클래스의 트성들을 상속받으면서 하위 클래스에서 나름대로 수정을 가하고 자기 자신의 고유한 특성을 갖는 관계

### 객체지향 설계 원칙(SOLID)

- 단일 책임의 원칙
  - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
- 개방 폐쇄 원칙
  - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원칙
- 리스코프 치환의 원칙
  - 서브 타입은 어디서나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙
- 인터페이스 분리의 원칙
  - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
  - 클라이언트가 사용하지 않는 인터페이스 떄문에 영향을 받아서는 안된다는 원칙
- 의존성 역전의 원칙
  - 실제 사용 관계는 바뀌지 않으며, 추상(추상 클래스, 인터페이스)을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙
  - 의존성 관계를 맺을 때 변화하기 쉬운 것보다는 변화가 없는 것에 의존 관계를 맺어라
  - 자주 바뀌는 하위 클래스보다 추상 클래스/인터페이스를 매개변수로 삼거나 참조하게 될 경우 변경에 따른 추가 수정이 없게 된다.

### 객체 지향 방법론 종류

- OOSE(Object Oriented Software Engineering)
  - Jacobson
  - 유스케이스에 의한 접근 방법
  - 분석 -> 설계 -> 구현 다계로 구성
  - 기능적 요구사항 중심
- OMT(Objected Modeling Technology)
  - Rumbaugh
  - 객체지향 분석, 시스템 설계, 오브젝트 설계 및 구현
  - 객체 모델링 -> 동적 모델링 -> 기능 모델링
  - 대형 프로젝트
- OOD(Object Oriented Design)
  - Booch
  - 설계 부분만 존재
  - 설계 문서화를 강조하여 다이어그램 중심
  - Micro + Macro
  - 분석과 설계 분리 불가능
  - 분석하는 데 이용한 객체 모델을 설계 모델에 사용
- Coad Yourdon -> ERD 사용
- Wirfs-Brock 분석 설계 구분 x,

## 디자인 패턴

- 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.

- 클래스 : 컴파일 타임에 정적으로 결정
  - 컴파일 타임 : 소스 코드를 작성하고 컴파일이라는 과정을 통해 기계어 코드로 변환되어, 실행 가능한 프로그램이 되는 과정이다.(정적 메모리 할당 수행)
- 객체 : 런타임에 동적으로 결정
  - 런타임: 파일 컴파일 과정을 마친 프로그램은 사용자에 의해 실행되며, 이러한 응용 프로그램이 동작하는 과정이다.(동적 메모리 할당)

* 생성 패턴
  - Builder
    - 생산 단계를 캡슐화하여 구축 공정을 동일하게 이용하도록 하는 패턴
  - Prototype
    - 복사하여 새 개체를 생성할 수 있도록 하는 패턴
  - Factory Method
    - 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화할 것인지는 서브 클래스가 결정하도록 하는 패턴
  - Abstract Factory
    - 생성군들을 하나에 모아놓고 팩토리 중에서 선택하게 하는 패턴
  - Singleton
    - 유일한 하나의 인스턴스를 보장하도록 하는 패턴
* 구조 패턴
  - Bridge
    - 추상과 구현을 분리하여 결합도를 낮춘 패턴
  - Decorator
    - 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
  - Facade
    - 하나의 인터페이스를 통해 느슨한 결합을 제공하는 패턴
  - Flyweight
    - 대량의 작은 객체들을 공유하는 패턴
  - Proxy
    - 대리인이 그 일을 대신 처리하는 패턴
  - Composite
    - 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴
  - Adatper
    - 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴
* 행위 패턴
  - Interpreter
    - 언어 규칙 클래스를 이용하는 패턴
  - Template Method
    - 알고리즘 골격의 구조를 정의한 패턴
  - Chain of responsibility
    - 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
  - Command
    - 요청 자체를 캡슐화하여 파라미터로 넘기는 패턴
  - Iterator
    - **내부 표현**은 보여주지 않고 순회하는 패턴
  - Mediator
    - 객체 간 상호작용을 캡슐화한 패턴
  - Memento
    - 상태 값을 미리 저장해두었다가 복구하는 패턴
  - Observer
    - 상태가 변할 때 의존자들에게 알리고, 자동 업데이트 하는 패턴
  - State
    - 객체 내부 상태에 따라서 행위를 변경하는 패턴
  - Strategy
    - 다양한 알고리즘을 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴
  - Visitor
    - 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴

# 인터페이스 설계

| 분류              | 설명                                                                                                                    |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------- |
| 기능적 요구사항   | 내 \* 외부 인터페이스 연계를 통해 수행될 기능과 관련되어 소프트웨어가 가져야 하는 기능적 속성에 대한 요구사항           |
| 비기능적 요구사항 | 내\*외부 인터페이스 연계 시의 성능, 사용의 용이성, 신뢰도, 보안성, 운용상의 제약, 안전성 등 시스템 전반에 대한 요구사항 |

## 요구 공학

- 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동이다.
- 형상 관리
  - 소프트웨어 생명주기 동안 발생하는 변경사항을 체계적으로 관리하여 소프트웨어의 품질보증을 향상시키는 관리적 활동

### 요구사항 도출 단계

- 델파이 기법
  - 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 하는 기법
- 워크숍
  - 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
  - 프로젝트에 참여하는 모든 핵심 인물으참여 필요
  - 참석자들은 해당 전문 영역별로 팀 협력이 필요하며 사전 준비가 요구.

### 요구사항 분석 단계

- 추출된 요구 사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
- 요구사항 할당
  - 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
  - 다른 구성요소와 어떻게 상호 작용하는지 분석을 통해 추가적인 요구사항 발견 가능.
- 요구사항 분석 단계 기법
  - 자료 흐름 지향 기법
    - Data Flow Diagram 및 Data Dictionary 활용
  - 객체지향 분석
    - UML 로 표준화
- 명세 단계 기법
  - 비정형 명세 기법
    - 자연어(개발자, 사용자 이해 용이)
  - 정형 명세 기법
    - Z-스키마, Petri NEts, 상태 차트 활용

### 정형 기술 검토 가이드라인

- 제품의 검토에만 집중한다.
- 의제를 제한하여 진행한다.
- 논쟁과 반박을 제한한다.
- 문제 영역을 명확히 표현한다.
- 참가자 수를 제한한다.
- 자원과 시간 일정을 할당한다.
- 검토과정과 결과를 재검토한다.

- 요구사항 검토 기법
  - 동료 검토
    - 2~3명이 진행하는 리뷰의 형태
    - 명세서 작성자가 명세서를 설명하고 이해관게자들이 설명을 들으면서 결함 발견
  - 워크 스루
    - 오류 조기 발견 목적
    - 검토 자료 회의 이전 배포 및 사전 검토
    - 짧은 시간 동안 사전 회의 진행을 통한 리뷰
  - 인스텍션
    - 저작자 외에 다른 전문가 혹은 팀이 검사하여 오류 찾기
- 기능적 요구사항 특성
  - 기능성 / 완전성 / 일관성
- 역공학 : 기존 개발된 시스템의 코드나 데이터로부터 설계 명세나 요구분석서 등을 도출해 내는 작업

## 인터페이스 대상 식별

- 시스템 아키텍처
  - 시스템의 구조, 행위, 동작 원리를 설명하는 프레임워크다.
  - 시스템 목적을 달성하기 위해서 시스템 각 컴포넌트가 무엇이며 어떻게 상호작용하는지, 정보가 어떻게 교환되는지를 설명한다.
- Application Server
  - 분산 네트워크 내의 컴퓨터 내에서 응용 프로그램에 비즈니스 로직을 제공하는 서버 프로그램이다.
- 대역폭
  - 주어진 데이터를 전송하는데 필요한 주파수폭이다. 따라서 전송해야 할 데이터의 양이나 시스템의 성능에 의해 대역폭이 결정되는데, 동일한 시간에 많은 정보를 보내기 위해서는 대역폭이 넓어야 한다.
- 인터페이스 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식을 정의하여 사용해야 한다.
  - 인터페이스 데이터 공통부
    - 인터페이스 표준 항목을 포함
  - '' 개별부
    - 송 \* 수신 시스템에서 업무 처리에 필요한 데이터 포함
  - 종료부
    - 전송 데이터의 끝을 표시하는 문자를 포함하여 종료 표시.
- 연계 서버(솔루션)
  - 데이터 송/수신
  - 데이터 암/복호화
  - 데이터 변환 / 매핑
  - 응답 처리
  - 완료 처리

## 인터페이스 상세 설계

- 직접 연계 방식
  - 중간 매개체가 없어 연계 처리속도가 빠르고 구현이 단순
  - 개발 비용 저렴
  - 송신 시스템과 수신 시스템 간의 결합도가 높아서 시스템 변경 시 민감
  - 보안을 위한 암/복호화 처리와 비즈니스 로직 구현을 인터페이스 별로 작성
  - 전사 시스템 인터페이스에 대한 통합 환경 구축이 어려움
- 간접 연계 방식
  - 송 \* 수신 처리 및 현황을 모니터링하고 통제하는 연계 서버를 활용하는 방식
  - 서로 다른 네트워크와 포로토콜 등 다양한 환경을 갖는 시스템들을 연계하고 통합 관리할 수 있음
  - 인터페이스 변경 시에도 유연한 대처가 가능

### 송\*수신 연계 기술

- DB 링크
  - 데이터베이스에서 제공하는 DB 객체를 이용
  - 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
  - 테이블명@DBLink명
- DB 연결
  - 수신 시스템의 WAS 에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀명을 이용
  - 송신 시스템의 Data Source = DB COnnection Pool 이름
- API / OPEN API
  - API명, 입출력 파라미터 벙보가 필요함.

### 통신 유형

- 실시간
  - 단방향
    - 데이터를 이용하고자 하는 시스템에서 거래를 요청하는 방식
    - 데이터를 전송하는 상대 시스템의 응답이 필요 없는 업무에 사용
    - 실시간 File, 실시간 DB 연계에도 이용
  - 양방향
    - 시스템 간의 거래를 상호 요청
    - 응답이 필요할 때
  - Sync
    - 데이터를 이용하고자 하는 시스템에서 거래 요청을 하고 응답이 올 때까지 대기하는 방식
    - 속도가 빠를 경우 사용
  - 비동기
    - 거래를 요청하는 서비스와 응답을 받아 처리하는 서비스가 분리되는 구조
    - 요청을 보내고 다른 작업을 하다가 데이터가 준비되었따는 신호르르 받으면 다시 처리
  - 지연(Deferred) 처리
    - 비동기, 단방향 유형과유사
    - 순차 처리 및 지연처리가 필요할 때
- 배치
  - DB/File 거래
    - 정해진 시간에 통신을 수행된느 방식
    - 연계 스케줄러에 의해 구동되는 이벤트 방식과 타이머에 의한 방식 존재

### 미들웨어 솔루션

- 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어이다.

- 서로 다른 프로토콜이나 시스템 운영체제, 데이터베이스와 애플리케이션 간에 통신을 지원해주는 소프트웨어를 의미한다.

#### 미들웨어 솔루션 유형

- DB 미들웨어
- 원격 프로시저 호출(Remote Procedure Call)
  - 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식
- 메시지 지향(Message-Oriented-Middleware)
  - 메시지 기반의 비동기형 메시지 전달 방식
  - 이기종 분산 DB 시스템의 데이터 동기르 위하여 사용
- 트랜잭션 처리 모니터
  - 온라인 업무에서 트랜잭션을 처리, 감시하는 미들웨어
  - 분산 트랜잭션을 처리하기 위한 미들웨어
- 레거시웨어
  - 기존의 애플리케이션이나 DB 기반에 새로운 업데이트된 기능을 덧붙이고자 할 때
- 객체 기반
  - 각기 다양한 기반으로 구축된 컴퓨터 간의 프로그램과 데이터의 교 환 및 변환 용이화
- WAS
  - 서버계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종시스템과의 애플리케이션 연동을 지원하는 미들웨어
  - HTTP 세션 처리를 위한 웹 서버 기능 뿐만 아니라, 민감한 기업 업무까지 처리 가능

### EAI와 ESB

- EAI(Enterprise Application Intergration)
  - 기업 내 각종 플랫폼 및 애플리케이션 간의 상호 연동이 가능해지도록 통합하는 솔루션
  - 동일한 플랫폼으로 커뮤니케이션 하는 것을 목적
  - 대상 시스템에 비표준 어뎁터를 배포하여 통합한다.
  - 집중형 토폴로지
  - 어댑터 브로커 메시지 큐
    - 어댑터 : 연결 장치
    - 브로커 : 시스템 상호 간 데이터가 전송될 때, 데이터 포맷과 코드를 변환하는 솔루션
    - 메시지 큐 : 비동기 메시지를 사용하는 다른 응용프로그램 사이에서 데이터를 송수신하는 기술
  - 단단한 통합
  - 기업 내부망
- ESB(Enterprise Service Bus)
  - 기업에서 운영되는 서로 다른 플래솜 및 플리케이션 관리 운영
  - 서비스 중심의 통합
  - 표준 API로 통합
  - 분상형 토폴로지
  - 웹 서비스, 지능형 라우터, 포맷 변환, 개방형 표준
  - 느슨한 통합
  - 기업 외부 채널망
