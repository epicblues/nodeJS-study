## Key

- 요구사항 분석
- 소프트웨어 아키텍처
- 객체지향
- 객체
- 디자인 패턴
  - 객체지향 프로그래밍 설계를 할 때 자주 발생하는 문제를 피하기 위해 사용
- 인터페이스
  - 서로 다른 두 시스템, 장치, 소프트웨어를 서로 이어주는 접속 및 중계시스템이다.

# 요구사항 확인

## 플랫폼 기능 분석

### 1. 플랫폼의 개념

- 플랫폼은 애플리케이션을 구동시키는 데 필요한 소프트웨어의 환경이다.
- 동일 플랫폼 내에서는 상호 호환이 가능하도록 만들어진 결합체를 의미한다.
- 공급자와 수요자 등 복수 그룹이 참여하여 각 그룹이 얻고자 하는 가치를 공정한 거래를 통해 교환할 수 있도록 구축된 환경이다.

### 2. 플랫폼의 유형

| 유형               | 설명                                             | 사례                      |
| ------------------ | ------------------------------------------------ | ------------------------- |
| 싱글 사이드 플랫폼 | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태 | 아이튠즈, 안드로이드 마켓 |
| 투 사이드 플랫폼   | 두 그룹을 중개하고 모두에게 개방하는 형태        | 소개팅 앱                 |
| 멀티 사이드 플랫폼 | 다양한 이해관계 그룹을 연결하여 중개하는 형태    | 페이스북 인스타그램       |

### 3. 플랫폼의 기능

- 소프트웨어개발과 운영비용이 감소하고 생산성이 향상된다.
- 동일 플랫폼의 커뮤니티를 형성하고 **네트워크 효과**를 유발한다.
  - 네트워크 효과
    - 어떤 상품에 대한 수요가 형성되면 이것이 다른 사람들의 상품 선택에 큰 영향을 미치는 현상이다.

### 4. 플랫폼 기능 분석 절차

| 순서 | 절차                  | 설명                                                                                                          |
| ---- | --------------------- | ------------------------------------------------------------------------------------------------------------- |
| 1    | 현행 플랫폼 자료 수집 | _ 현행 시스템 담당자 제시 자료와 인터뷰를 통해 자료 수집 / 파악<br/> _ 인터뷰 결과서, 현행 플랫폼 구성도 도출 |
| 2    | 수집 자료 분석        | \* 수집된 자료에 산발적으로 존재하는 정보들의 취합/ 정제 작업을 실시                                          |
| 3    | 결과 산출물 작성      | \* 수집된 자료를 기반으로 플랫폼 기능분석도 작성                                                              |

## 플랫폼 성능 특성 분석

### 1. 플랫폼 성능 특성 분석 이유

- 플랫폼 성능 분석을 통해 사용자의 서비스 이용 시 속도의 적정성을 알 수 있다.
- 사용자 요구사항 중 성능에 대한 개선요청 항목은 현재 시스템 플랫폼 성능이 느린 것으로 제기될 가능성이 높다.

### 2. 플랫폼 성능 분석 기법

| 기법          | 설명                                                 | 산출물                          |
| ------------- | ---------------------------------------------------- | ------------------------------- |
| 사용자 인터뷰 | 현행 플랫폼 사용자 인터뷰를 통해 속도의 적정성 확인  | 인터뷰 결과서                   |
| 성능 테스트   | 현행 플랫폼을 대상으로 성능, 부하 테스트를 수행      | 성능 테스트, 부하 테스트 결과서 |
| 산출물 점검   | 현행 플랫폼과 유사한 타사 제품의 성능 자료 등을 분석 | **벤치마킹 테스트** 결과서      |

- 벤치마킹 테스트 : 도입하려는 제품군의 대상 Vendor를 설정하여 해당 제품군의 성능을 비교하는 테스트이다.

### 3. 플랫폼 성능 특성 측정 항목

| 측정 항목                  | 설명                                                                    |
| -------------------------- | ----------------------------------------------------------------------- |
| 경과 시간(Turnaround Time) | 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간    |
| 사용률                     | 애플리케이션이 의뢰한 작업을 처리하는 동안 CPU, 메모리 등의 자원 사용률 |
| 응답 시간                  | 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 떄까지 걸린 시간    |
| 가용성                     | 일정 시간 내에 애플리케이션이 처리하는 일의 양                          |

## 운영체제 분석

### 1. 운영체제의 개념

- 운영체제는 하드웨어및 소프트웨어 자원을 효율적으로 관리하며 공통된 기능을 제공하는 소프트웨어이다.
- 사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 소프트웨어이다.

### 2. 운영체제 현행 시스템 분석

#### 품질 측면

- 신뢰도
  - 장기간 시스템 운영 시 운영체제의 장애 발생가능성
  - 운영체제의 버그로 인한 재기동 여부
- 성능
  - 대규모 및 대량 파일 작업(배치 작업)처리
    - **Batch Job** : 실시간 작업의 반대 개념으로 일련의 작업들을 하나의 작업 단위로 묶어서 일괄로 처리하는 작업이다.
  - 지원 가능한 메모리 크기(32bit, 64bit)

#### 지원 측면

- 기술 지원
  - 공급사들의 안정적인 기술 지원
  - 오픈 소스 여부
- 주변 기기
  - 설치 가능한 하드웨어
  - 다수의 주변 기기 지원 여부
- 구축 비용
  - 지원 가능한 하드웨어비용
  - 설치할 응용 프로그램의 라이선스 정책 및 비용
  - 유지 및 관리 비용

## 4, 네트워크의 분석

### 1. 네트워크의 개념

- 네트워크는 컴퓨터 장치들이 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환하는 기술이다.
- 데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이와 같은 무선 매체를 통해 성립된다.

### 네트워크 현행 시스템 분석

- 현행시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석한다.
- 네트워크 구성도의 작성을 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있다.
- **백본망**, **라우터**, **스위치**, **게이트웨이**, **방화벽** 등을 대상으로 분석한다.
  - 백본망(BackBone Network)
    - 다양한 네트워크를 상호 연결하는 컴퓨터 네트워크의 일부로서 각기 다른 LAN이나 부분망 간에 정보를 교환하기 위한 경로를 제공하는 망이다.
  - 라우터
    - 3계층 데이터 패킷을 발신지에서 목적지까지 전달하기 위해 최적의 경로를 지정하고, 이 경로를 따라 데이터 패킷을 다음 장치로 전달하는 네트워크 장비이다.
  - 스위치
    - 2계층 장비로서, 동일 네트워크 내에서 출발지에 들어온 데이터 프레임을 목적지 MAC 주소 기반으로 빠르게 전달하는 네트워크 장비이다.
  - 게이트웨이
    - 컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 네트워크 장비이다.
  - 방화벽
    - 외부로부터 불법 침입과 내부의 불법 정보 유출을 방지하고, 내/외부 네트워크의 상호 간 영향을 차단하기 위한 보안 시스템이다.
- 물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 쉽다.
- 네트워크 장애 발생 추적 및 대응 등의 다양한 용도로 활용할 수 있다.

## DBMS 분석

### 1. DBMS의 개념

- DBMS는 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램이다.

### 2. DBMS의 기능

| 기능            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 중복 제어       | 동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지      |
| 접근 통제       | 권한에 따라 데이터에 대한 접근 제어                          |
| 인터페이스 제공 | 사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공         |
| 관계 표현       | 서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공 |
| 샤딩/파티셔닝   | 구조 최적화를 위해 작은 단위로 나누는 기능 제공              |
| 무결성 제약조건 | 무결성에 관한 제약 조건을 정의/검사하는 기능 제공            |
| 백업 및 회복    | 데이터베이스 장애 발생 시 데이터의 보존 기능 제공            |

### 3. 데이터베이스 현행 시스템 분석

- 성능 측면
  - 가용성
    - 장기간 시스템을 운영할 때 장애 발생 가능성
    - 백업 및 복구 편의성
    - DBMS 이중화 및 복제 지원
  - 성능
    - 대규모 데이터 처리 성능
    - 대량 거래 처리 성능
    - 다양한 튜닝 옵션 지원 여부
    - 비용 기반 최적화 지원 및 설정의 최소화
  - 상호 호환성
    - 설치 가능한 운영체제 종류
    - 다양한 운영체제에서 지원되는 **JDBC**, **ODBC**
      - JDBC(Java Database Connectivity)
      - ODBC(_**Open**_ DataBase Connectivity)
- 지원 측면
  - 기술 지원
    - 공급 업체들의 안정적인 기술 지원
    - 다수의 사용자 간의 정보 공유
    - 오픈 소스 여부
  - 구축 비용
    - 라이선스 정책 및 비용
    - 유지 및 관리 비용

## 비즈니스 융합 분석

- 비즈니스 융합은 융합 기술이 제공하는 기회나 융합의 원리를 적용해서 새로운 제품, 서비스, 산업을 창출하거나 기존 제품을 혁신하기 위한 기업 활동이다.
- 스마트 팩토리
  - 기획/설계, 생산, 유통/판매 등 전 과정을 ICT 기술로 통합, 최소비용 및 시간으로 고객 맞춤형 제품을 생산하는 지능화된 공장이다.
- 옴니채널
  - 소비자가 온라인, 오프라인, 모바일 등 다양한 경로로 상품을 검색하고 구매할 수 있도록 하는 서비스이자, 각 유통 채널의 특성을 결합해 어떤 채널에서든 같은 매장을 이용하느 것처럼 느낄 수 있도록 한 쇼핑 환경이다.

# 요구사항 확인

## 요구분석 기법

### 1. 요구분석(Requirements Analysis)의 개념

- 요구분석은 도출된 요구사항 간 상충을 해결하고 소프트웨어의 범위를 파악하여 **외부 환경**과의 상호작용을 분석하는 과정이다.
  - 외부 환경 : 광의적인 측면에서 하드웨어, 소프트웨어, 네트워크 등의 환경이다.
  - 사용자가 인터넷 환경에서 큐넷 서버로 접근해서 기사시험 접수를 한다고 가정하면 사용자(**외부 환경**)와 큐넷 시스템의 상호작용을 분석한다. 여기서 요구사항은 기사시험을 정상적으로 접수하는 것.
- 요구분석은 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.

### 2. 요구분석의 특징

- 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있다.
- 보다 구체적인 명세를 위해 **소단위 명세서**가 활용될 수 있다.
- 개발 비용이 가장 많이 소요되는 단계는 <U>**아니다**</U>

### 3. 요구분석 기법

1. 요구사항 분류

   - 요구사항이 기능인지 비 기능인지 확인
   - 요구사항이 소프트웨어에 미치는 영향의 범위를 파악
   - 요구사항이 소프트웨어 생명주기 동안 변경이 발생하는지를 확인
   - 하나 이상의 상위 요구사항에서 유도된 것인지 또는 이해관계자나 다른 원천으로부터 직접 발생한 것인지 분류

2. 개념 모델링 생성 및 분석

   - 모델 : 요구사항을 더 쉽게 이해할 수 있도록 상황을 단순화, 개념적으로 표현한 것.
   - 모델링 표기는 주로 UML을 사용

3. 요구사항 할당

   - 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
   - 다른 구성요소와 어떻게 상호작용하는지 분석 -> 추가적인 요구 사항 발견 가능

4. 요구사항 협상

   - 두 명의 이해관계자가 서로 상충되는 내용을 요구하는 경우, 적절한 지점에서 합의하기 위한 기법
   - 충돌할 떄 요구 사항의 우선순위를 각각 부여하면 무엇이 더 중요한지 인식 가능

5. 정형 분석

   - 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현
   - 구문(Syntax)과 의미(Semantics)를 갖는 정형화된 언어를 사용하여 수학적 기호로 표현
   - 마지막 단계

### UML : Unified Modeling Language

- 의존 관계
  - 사물과 사물 사이에 서로 연관은 있으나 필요에 따라 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현.
  - 사물의 변화가 다른 사물에도 영향을 미치는 관계

# 2. 화면 설계

## UI 개요

### 1. UI 개념

- 사용자 인터페이스는 넓은 의미에서 사용자와 시스템 사이에서 의사 소통할 수 있도록 고안된 물리적, 가상의 매개체이다.
- 좁은 의미로는 정보 기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면이다ㅌ
- UX(User Experience) : 제품과 시스템, 서비스 등을 사용자가 직, 간접적으로 경험하면서 느끼고 생각하는 총체적 경험
  - 사용과 맥락
    - 사회적 구조 및 과업
    - 애플리케이션 영역
    - 사용자와 기계 사이의 적응성
  - 사용자(UI)
    - 인간 정보처리 과정
    - 사회적 구조 및 과업
    - 인간공학적 요소
  - 컴퓨터(UI)
    - 입출력 장치
    - 상호작용 기술
    - 컴퓨터 그래픽스
    - 상호작용 구조

### UI 유형

|     유형     | 특징                               | 설명                                                         |
| :----------: | ---------------------------------- | ------------------------------------------------------------ |
|     CLI      | 정적인 텍스트 기반 인터페이스      | 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스        |
|     GUI      | 그래픽 반응 기반 이터페이스        | 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스 |
| NUI(Natural) | 직관적 사용자 반응 기반 인터페이스 | 사용자가 가진 경험을 기반으로 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스 |
| OUI(Organic) | 유기적 상호작용 기반 인터페이스    | 입력장치가 곧 출력장치가 되고, 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스 |

### UI 설계 원칙

| 설계 원칙 |                             설명                             |                부특성                 |
| :-------: | :----------------------------------------------------------: | :-----------------------------------: |
|  직관성   |       누구나 쉽게 이해하고, 쉽게 사용하라 수 있어야 함       | 쉬운 검색<br/>쉬운 사용성<br/>일관성  |
|  유효성   |   정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작    |        쉬운 오류 처리 및 복구         |
|  학습성   |    초보자와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작    |   쉽게 학습  쉬운 접근   쉽게 기억    |
|  유연성   | 사용자의 **인터렉션**을 최대한 포용하고, 실수를 방지할 수 있도록 제작 | 오류 예방<br/>실수 포용<br/>오류 감지 |

### UI 시스템의 필요 기능

* 사용자의 입력을 검증한다.
* 에러 처리와 에러 메시지 처리를 한다.
* 도움과 프롬프트를 제공한다.

## UI 표준

- UI 표준은 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약이다.

|         UI 표준 구성          | 설명                                                         |
| :---------------------------: | ------------------------------------------------------------ |
|       전체적인 UX 원칙        | 사용자의 관점에서 사용자 업무를 효율적으로 수행할 수 있는 UX 원칙 정의 |
|         정책 및 철학          | 조직의 목표나 정체성을 포함하는 정책 및 철학 설정            |
|       UI 스타일 가이드        | UI에 대한 구동 환경 및 레이아웃 등을 정의                    |
|       UI 패턴 모델 정의       | **CRUD 방식**을 기반으로 데이터 입력, 출력 패턴 모델 정의    |
| UI 표준 수립을 위한 조직 구성 | UI 팀 및 표준 개발 팀을 주축으로 추진 조직 구성              |

* 그리드 - 레이아웃을 격자 모양의 테이블 형태로 표현하는 방법

### UI 패턴 모델 정의

* CRUD 방식을 기반으로 하여 데이터의 입력과 출력을 처리하는 화면 흐름을 포함하여 오퍼레이션 방식에 대한 표준 절차를 표시하고, UI 패턴 모델을 개발한다.

#### 패턴 별 표준 개발 방법 정의

* 업무 화면 클라이언트 정의
  * 제안 단계에서 결정된 클라이언트를 통해 설계자는 개발 시에 필요한 공통 요소 식별, 디렉토리 구성, 개발 환경 구축 부분 도출
  * 클라이언트에 출력되는 UI는 X-Internet으로 대변되는 **리치 클라이언트**와 일반 JSP, HTML 기반의 **씬 클라이언트**가 존재
    * 리치 클라이언트 : SW의 실행을 클라이언트에서 책임지는 기술로 서버는 클라이언트에서 요청한 SW의 실행 코드를 스트림 혀 형태로 제공하고, 클라이언트는 서버로부터 스트리밍되는 SW 코드를 클라이언트 PC의 자원을 이용하여 실행하는 기술이다.
    * 씬 클라이언트 : 소프트웨어의 실행을 전적으로 서버에서 책임지는 기술. 서버에서 가상머신을 이용하여 클라이언트의 데이터와 소프트웨어를 관리 및 실행하는 기술이다.
* 서버 컨트롤러 정의
  * 프레임워크를 도입한다면 해당 프레임워크가 제공하는 방식 채택
  * 별도의 클라이언트 제품 도입하는 경우 서버 컨트롤러와의 연동 방식 결정
* 서버 메시지 및 예외 처리 정의
  * S(System)
    * 시스템 오류로 인해 발생하는 메시지
    * 런타임 예외를 전달할 떄 사용되며, 모든 트랜잭션은 자동으로 복원(Rollback)
  * E(Error)
    * 업무 처리 로직의 일환으로 애플리케이션 예외를 전달할 떄 사용
    * 모든 트랜잭션은 자동으로 복원
  * I(Information)
    * 정상적인 업무 처리나 결과나 정보에 대한 확인
    * 메시지를 사용자에게 알려주고자 할 떄 사용
    * 이때 모든 트랜잭션은 커밋(Commit) 됨.
* 클라이언트 - 서버 간 데이터 변환 정의
  * 어떤 방식의 Object를 사용할 것인지를 먼저 결정
  * 클라이언트와 서버 간의 데이터 형태 변환을 어떻게 처리할 것인지 방안 마련

### 스토리보드

* 스토리보드는 UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임, 기능에 대한 정의, 데이터베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서이다. 
* UI 화면 설계를 위해서는 스토리보드, 와이어 프레임, 프로토타입이 활용된다.

| 구분         | 설명                                                         | 도구                                   |
| ------------ | ------------------------------------------------------------ | -------------------------------------- |
| 와이어프레임 | 이해관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업 | 파워포인트 / 키노트 / 스케치/ 일러스트 |
| 스토리보드   | 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터 베이스 연동 모든 정보가 담겨 있는 산출물 | 파워포인트 / 키노트 / 스케치           |
| 프로토타입   | 정적인 화면으로 설계된 와이어프레임 또는 스토리보드에 동적 효과를 적용함으로써 실제 구현된 것처럼 시뮬레이션할 수 있는 모형 | HTML /  CSS                            |
|              |                                                              |                                        |

스토리보드 작성 절차

	1. 전체 개요 작성
	1. 서비스 흐름 작성(어떤 버튼을 누르면 어떤 이벤트가 발생하는지, 다음 화면은 무엇인지, 어떤 서버와 통신하는지 등)
	1. 스타일 확정
	1. 메뉴별 화면 설계도 작성 및 상세설명
	1. 추가 관련 정보 작성

* Profile : 어떤 시스템을 일정 범위 내에서 한정적으로 특징 지우는 그룹화된 값이다.
* UI 컨셉션 : 정리된 요구사항을 구체화하는 단계로 **화면 디자인 단계 전**에 대표 화면 설계를 진행하는 단계

## UI 설계

### UI 설계 프로세스

1. 문제 정의
2. 사용자 모델 정의
3. 작업 분석
4. 컴퓨터 오브젝트 및 기능 정의
5. 사용자 인터페이스 정의(마우스, 키보드 등 컴퓨터와 상호 작용을 하는 오브젝트 선택)
6. 디자인 평가(GoalsOperatorsMethodsSelection, 휴리스틱(경험 기반 문제 해결 학습 발견))

### UI 흐름 설계

1. 화면에 표현되어야 할 기능 작성
2. 화면의 입력 요소 확인
3. UI  요구 사항을 기반으로 유스케이스 설계(액터별 시나리오 작성)
4. 기능 및 양식 확인

* 집적 회로(Integrated Circuit)
  * 하나의 반도체 기판에 다수의 능동소자(트랜지스터, 진공관 등)와 수동소자(저항, 콘덴서, 저항기 등)를 초소형으로 집적, 서로 분리될 수 없는 구조로 만든 완전한 회로기능을 갖춘 기능소자이다.
* 목업(Mockup)
  * 비용 절감 목적으로 실제 제품이 나오기 전 만드는 모형을 의미한다.
* 프로토타이핑은 실제 구현은 아니고 결과물에 대해 이해를 돕기 위해 수행하는 것

# 애플리케이션 설계

## 공통 모듈 설계

### 공통 모듈의 개념

* 모듈의 개념
  * 모듈은 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭하는 용어이다.
  * 모듈화를 통해 분리된 시스템의 기능들로 서브 프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용된다.
* 모듈의 특징
  * 각각의 모듈은 상대적으로 독립성을 가지고 있다.
  * 모듈 내부에는 그 모듈을 하나로 통합하는 수많은 조합이 존재할 수 있다.
  * 모듈은 **단독으로** 컴파일 할 수 있으며 재사용 할 수 있다.
  * 독립성이 높은 모듈일수록 모듈 수정 시에도 다른 모듈들에는 영향을 거의 미치지 않고, 오류가 발생 시에도 쉽게 해결할 수 있다.
  * 모듈의 독립성은 **결합도와 응집도**에 의해 측정되며, 독립성을 높이려면 모듈의 **결합도는 약하게**, **응집도는 강하게**, 모듈으 크기는 작게 만들어야 한다.
* 공통 모듈의 개념
  * 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미한다.
  * 자체적으로 **컴파일**가능하고 다른 프로그램에서 재사용 가능.
  * 여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈을 의미하며 날짜 처리를 위한 유틸리티 모듈 등이 해당된다.

### 모듈화

 * 모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 소프트웨어제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법이다.

#### 모듈화 기법

| 기법      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| 루틴      | 소프트웨어에서 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임 |
| 메인 루틴 | 프로그램의 주요한 부분이며, 전체의 개략적인 동작 절차를 표시하도록 만들어진 루틴 <br/>메인 루틴은 서브 루틴을 호출 |
| 서브 루틴 | 메인 루틴에 의해 필요할 떄마다 호출되는 루틴                 |



#### 모듈화 유형

* 응집도
  * 모듈 내부에서 구성요소 간에 밀접한 관계를 맺고 있는 정도
  * 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성
* 결합도
  * 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내는 정도
  * 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어짐

| 구분           | 팬인(Fan-In)                                                 | 팬아웃(Fan-Out)                             |
| -------------- | ------------------------------------------------------------ | ------------------------------------------- |
| 개념           | 어떤 모듈을 제어(호출)하는 모듈의 수                         | 어떤 모듈에 의해 제어되는 모듈의 수         |
| 모듈 숫자 계산 | 모듈 자신을 기준으로 모듈에 들어오면 팬인                    | 모듈 자신을 기준으로 모듈에서 나가면 팬아웃 |
| 고려사항       | 높을수록 재사용 측면에서 설계가 잘 된 것. 단일 장애점 발생 가능, 높을수록 관리 비용 및 테스트 비용 증가 | 불필요한 모듈 호출 검토 필요                |



## 설계 모델링

* 설계 모델링은 요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법이다.

### 설계 모델링 유형

* 구조 모델링
  * 소프트웨어를 구성하는 컴포넌트들의 유형, 인터페이스, 내부 설계 구조 및 이들의 상호 연결 구조를 모델링
  * 시스템의 구성요소들과 이들 사이의 구조적인 관계와 특성들을 모델링
  * 프로시저, 데이터 구조, 모듈, 파일 구조
    * 프로시저 : 프로그램을 기능에 따라 여러 개의 단위로 분해하여 작성하는 것으로 크게 서브 프로시저와 함수 프로시저로 나뉜다.
* 행위 모델링
  * 소프트웨어의 구성요소들의 기능들과 이들이 언제, 어떠한 순서로 기능을 수행하고 상호작용하는지를 모델링
  * 언제 어떠한 순서로 수행되는가와 같은 동적인 특성들을 모델링
    * 입력 데이터, 출력 데이터, 데이터 흐름, 데이터 변환, 데이터 저장 등

### 코드 설계

* 코드 설계는 데이터의 분류나 조합을 쉽게 하기 위하여 사물을 표현하는 코드를 설계하는 기법이다.

#### 코드의 기능

|   기능    | 설명                                                         |
| :-------: | ------------------------------------------------------------ |
|  표준화   | 정보를 종류, 모양, 크기등의 일정한 기준에 따라 통일적으로 표현하는 기능 |
|   분류    | 정보들을 동일한 특성을 가진 데이터로 그룹화하여 나누는 기능  |
|   식별    | 다른 것과 구별될 수 있는 기능                                |
|   배열    | 일련의 순서로 나열할 수 있는 기능                            |
|  간소화   | 정보의 표현 간소화                                           |
|   연상    | 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능 |
|  암호화   | 정보의 외부 표현을 감추고자 하는 기능                        |
| 오류 검출 | 정보 입력이나 관리 시 잘못된 정보를 찾아내는 기능            |

#### 코드 설계 종류

* 연상 코드
  * 코드만 보고 대상을 연상할 수 있도록 명칭 일부를 약호(간단하고 알기 쉽게 나타내어 만든 부호) 형태로 넣어 구성된 코드
  * ex ) 나라이름(KR, US)
* 블록 코드
  * 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 코드
  * 구분 코드라고 함
  * 전화번호에서 지역번호와 국번(같은 지역끼리 공통)
* 순차 코드
  * 일정한 기준에 따라 순서대로 일련번호를 부여한 코드
  * 중고등 학생들으반에서 번호(가나다순으로 1번 , 2번...)
* 표의 숫자 코드(Significant Digit Code)
  * 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등을 표시한 코드
* 그룹 분류식 코드
  * 대상을 기준에 따라 대분류, 중분류, 소분류로 구분하여 번호를 부여한 코드
  * 학번(입학 연도 - 일련번호)

### HIPO(Hierarchy Input Process Output)

* 하향식 소프트웨어 개발을 위한 문서화 도구

| 종류        | 설명                                                 |
| ----------- | ---------------------------------------------------- |
| 가시적 도표 | 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조도 |
| 총체적 도표 | 입력-처리-출력에 대한 정보를 제공하는 도표           |
| 세부적 도표 | 총체적 도표에 표시된 기능 상세히 기술                |

## 소프트웨어 아키텍처

* 소프트웨어 아키텍처는 여러 가지 소프트웨어 구성 요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조이다.
* 아키텍처는 시스템의 비기능적인 요소에 집중해서 만들어지고, 기능적인 요소도 구료한다.

#### 4 + 1 뷰

* 유스케이스 뷰
  * 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  * 사용자, 설계자, 개발자, 테스트 관점
* 논리 뷰
  * 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  * 설계자, 개발자 관점
* 프로세스 뷰
  * 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  * 개발자, 시스템 통합자 관점
* 구현 뷰
  * 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
  * 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
* 배포 뷰
  * 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

### 소프트웨어 아키텍처 패턴

* 계층화 패턴(Layered Pattern)

  * 시스템을 계층으로 구분하여 구성하는 패턴
  * 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공
  * 계층화 패턴은 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어짐

* 클라이언트 - 서버 패턴

  * 하나의 서버와 다수의 클라이언트
  * 서버는 계속 클라이언트로부터 요청을 대기

* 파이프 - 필터 패턴

  * 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능
  * 서브 시스템의 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
  * 필터 컴포넌트는 재사용성이 조혹, 추가가 쉽기 때문에 확장이 용이

* 브로커 패턴

  * 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴
  * 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행
  * 서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주며(Publish), 클라이언트가 브로커에 서비스르 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 Redirection함.

* 모델 - 뷰 - 컨트롤러 패턴

  * 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화하는 패턴

  * | 패턴     | 기능                               |
    | -------- | ---------------------------------- |
    | 모델     | 핵심 기능과 데이터 보관            |
    | 뷰       | 사용자에게 정보 표시               |
    | 컨트롤러 | 사용자로부터 요청을 입력 받앛 ㅓ리 |

  * 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행 가능

  * 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합.

## 객체지향 설계

* 클래스는 객체지향 프로그램에서 데이터를 **추상화**하는 단위이다.

* 객체의 행위(메서드)는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용
* 객체마다 각각의 상태와 식별성을 가짐
* 메시지
  * 객체 간 상호작용을 하기 위한 수단
  * 객체 간의 상호작용은 메시지를 통해 이루어짐
  * 메시지는 객체에서 객체로 전달됨

* 인스턴스
  * 객체지향 기법에서 클래스에 속한 각각의 객체
  * 실제로 메모리상에 할당

### 객체지향 기법

* 캡슐화
  * 서로 관련성이 많은 데이터와 이와 관련된 함수들을 한 묶음으로 처리하는 기법
  * 결합도가 낮아지고 재사용이 용이
  * 인터페이스가 단순화 됨
  * 정보은닉과 관계가 깊음
  * 변경 발생 시 오류의 파급 효과가 작음
* 상속성
  * 상위 클래스의 속성과 메소드를 하위 클래스에서 **재정의 없이** 물려받아 사용하는 기법
* 다형성
  * 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
  * **오버로딩**, **오버라이딩**이 대표적
    * 오버로딩 : 매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러 개 가지는 기법
    * 오버라이딩 : 자식 클래스가 부모 클래스의 메서드 재정의해서 사용
* 추상화
  * 공통 성질을 추출하여 추상 클래스를 설정하는 기법
  * 기능 추상화, 자료 추상호, 제어 추상화
* 정보은닉
  * 코드 내부 데이터와 메소드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술
  * Side-Effect를 최소화하기 위하여 사용
* 관계성
  * 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법
    * 연관화
      * is-member-of 관계
      * 클래스와 객체의 참조 및 이용관계
      * 같은 계층에 속하는 클래스들 사이의 상호 의존성을 보여주는 비계층적 관계성을 나타냄
    * 집단화
      * is part of 관계,  part-whole 관계
      * 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 특징
      * 일반화와 달리 상위 클래스의 성질들이 하위 클래스로 상속되지는 않음
    * 분류화
      * is-instance-of
      * 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스
    * 일반화
      * is-a 관계
        * 클래스들 간의 개념적인 포함 관계
        * 상위 클래스의 특성을 하위 클래스가 상속받음
    * 특수화
      * is-a 관계
        * 상위 클래스의 트성들을 상속받으면서 하위 클래스에서 나름대로 수정을 가하고 자기 자신의 고유한 특성을 갖는 관계



### 객체지향 설계 원칙(SOLID)

* 단일 책임의 원칙
  * 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
* 개방 폐쇄 원칙
  * 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원칙
* 리스코프 치환의 원칙
  * 서브 타입은 어디서나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙
* 인터페이스 분리의 원칙
  * 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
  * 클라이언트가 사용하지 않는 인터페이스 떄문에 영향을 받아서는 안된다는 원칙
* 의존성 역전의 원칙
  * 실제 사용 관계는 바뀌지 않으며, 추상(추상 클래스, 인터페이스)을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙
  * 의존성 관계를 맺을 때 변화하기 쉬운 것보다는 변화가 없는 것에 의존 관계를 맺어라
  * 자주 바뀌는 하위 클래스보다 추상 클래스/인터페이스를 매개변수로 삼거나 참조하게 될 경우 변경에 따른 추가 수정이 없게 된다.

### 객체 지향 방법론 종류

* OOSE(Object Oriented Software Engineering)
  * Jacobson
  * 유스케이스에 의한 접근 방법
  * 분석 -> 설계 -> 구현 다계로 구성
  * 기능적 요구사항 중심
* OMT(Objected Modeling Technology)
  * Rumbaugh
  * 객체지향 분석, 시스템 설계, 오브젝트 설계 및 구현
  * 객체 모델링 -> 동적 모델링  -> 기능 모델링
  * 대형 프로젝트
* OOD(Object Oriented Design)
  * Booch
  * 설계 부분만 존재
  * 설계 문서화를 강조하여 다이어그램 중심
  * Micro + Macro
  * 분석과 설계 분리 불가능
  * 분석하는 데 이용한 객체 모델을 설계 모델에 사용
* Coad Yourdon -> ERD 사용
* Wirfs-Brock 분석 설계 구분 x, 

## 디자인 패턴

* 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.

* 클래스 : 컴파일 타임에 정적으로 결정
  * 컴파일 타임 : 소스 코드를 작성하고 컴파일이라는 과정을 통해 기계어 코드로 변환되어, 실행 가능한 프로그램이 되는 과정이다.(정적 메모리 할당 수행)
* 객체 : 런타임에 동적으로 결정
  * 런타임: 파일 컴파일 과정을 마친 프로그램은 사용자에 의해 실행되며, 이러한 응용 프로그램이 동작하는 과정이다.(동적 메모리 할당)

- 생성 패턴
  - Builder
    - 생산 단계를 캡슐화하여 구축 공정을 동일하게 이용하도록 하는 패턴
  - Prototype
    - 복사하여 새 개체를 생성할 수 있도록 하는 패턴
  - Factory Method
    - 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화할 것인지는 서브 클래스가 결정하도록 하는 패턴
  - Abstract Factory
    - 생성군들을 하나에 모아놓고 팩토리 중에서 선택하게 하는 패턴
  - Singleton
    - 유일한 하나의 인스턴스를 보장하도록 하는 패턴
- 구조 패턴
  - Bridge
    - 추상과 구현을 분리하여 결합도를 낮춘 패턴
  - Decorator
    - 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
  - Facade
    - 하나의 인터페이스를 통해 느슨한 결합을 제공하는 패턴
  - Flyweight
    - 대량의 작은 객체들을 공유하는 패턴
  - Proxy
    - 대리인이 그 일을 대신 처리하는 패턴
  - Composite
    - 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴
  - Adatper
    - 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴
- 행위 패턴
  - Interpreter
    - 언어 규칙 클래스를 이용하는 패턴
  - Template Method
    - 알고리즘 골격의 구조를 정의한 패턴
  - Chain of responsibility
    - 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
  - Command
    - 요청 자체를 캡슐화하여 파라미터로 넘기는 패턴
  - Iterator
    - **내부 표현**은 보여주지 않고 순회하는 패턴
  - Mediator
    - 객체 간 상호작용을 캡슐화한 패턴
  - Memento
    - 상태 값을 미리 저장해두었다가 복구하는 패턴
  - Observer
    - 상태가 변할 때 의존자들에게 알리고, 자동 업데이트 하는 패턴
  - State
    - 객체 내부 상태에 따라서 행위를 변경하는 패턴
  - Strategy
    - 다양한 알고리즘을 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴
  - Visitor
    - 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴

# 인터페이스 설계

| 분류              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| 기능적 요구사항   | 내 * 외부 인터페이스 연계를 통해 수행될 기능과 관련되어 소프트웨어가 가져야 하는 기능적 속성에 대한 요구사항 |
| 비기능적 요구사항 | 내*외부 인터페이스 연계 시의 성능, 사용의 용이성, 신뢰도, 보안성, 운용상의 제약, 안전성 등 시스템 전반에 대한 요구사항 |

## 요구 공학

* 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동이다.
* 형상 관리
  * 소프트웨어 생명주기 동안 발생하는 변경사항을 체계적으로 관리하여 소프트웨어의 품질보증을 향상시키는 관리적 활동

### 요구사항 도출 단계

* 델파이 기법
  * 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 하는 기법
* 워크숍
  * 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
  * 프로젝트에 참여하는 모든 핵심 인물으참여 필요
  * 참석자들은 해당 전문 영역별로 팀 협력이 필요하며 사전 준비가 요구.

### 요구사항 분석 단계

* 추출된 요구 사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
* 요구사항 할당
  * 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
  * 다른 구성요소와 어떻게 상호 작용하는지 분석을 통해 추가적인 요구사항 발견 가능.
* 요구사항 분석 단계 기법
  * 자료 흐름 지향 기법
    * Data Flow Diagram 및 Data Dictionary 활용
  * 객체지향 분석
    * UML 로 표준화
* 명세 단계 기법
  * 비정형 명세 기법
    * 자연어(개발자, 사용자 이해 용이)
  * 정형 명세 기법
    *  Z-스키마, Petri NEts, 상태 차트 활용

### 정형 기술 검토 가이드라인

* 제품의 검토에만 집중한다.
* 의제를 제한하여 진행한다.
* 논쟁과 반박을 제한한다.
* 문제 영역을 명확히 표현한다.
* 참가자 수를 제한한다.
* 자원과 시간 일정을 할당한다.
* 검토과정과 결과를 재검토한다.

* 요구사항 검토 기법
  * 동료 검토
    * 2~3명이 진행하는 리뷰의 형태
    * 명세서 작성자가 명세서를 설명하고 이해관게자들이 설명을 들으면서 결함 발견
  * 워크 스루
    * 오류 조기 발견 목적
    * 검토 자료 회의 이전 배포 및 사전 검토
    * 짧은 시간 동안 사전 회의 진행을 통한 리뷰
  * 인스텍션
    * 저작자 외에 다른 전문가 혹은 팀이 검사하여 오류 찾기
* 기능적 요구사항 특성
  * 기능성 / 완전성 / 일관성
* 역공학 : 기존 개발된 시스템의 코드나 데이터로부터 설계 명세나 요구분석서 등을 도출해 내는 작업

## 인터페이스 대상 식별

* 시스템 아키텍처 
  * 시스템의 구조, 행위, 동작 원리를 설명하는 프레임워크다.
  * 시스템 목적을 달성하기 위해서 시스템 각 컴포넌트가 무엇이며 어떻게 상호작용하는지, 정보가 어떻게 교환되는지를 설명한다.
* Application Server
  * 분산 네트워크 내의 컴퓨터 내에서 응용 프로그램에 비즈니스 로직을 제공하는 서버 프로그램이다.
* 대역폭
  * 주어진 데이터를 전송하는데 필요한 주파수폭이다. 따라서 전송해야 할 데이터의 양이나 시스템의 성능에 의해 대역폭이 결정되는데, 동일한 시간에 많은 정보를 보내기 위해서는 대역폭이 넓어야 한다.
* 인터페이스 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식을 정의하여 사용해야 한다.
  * 인터페이스 데이터 공통부
    * 인터페이스 표준 항목을 포함
  * '' 개별부
    * 송 * 수신 시스템에서 업무 처리에 필요한 데이터 포함
  * 종료부
    * 전송 데이터의 끝을 표시하는 문자를 포함하여 종료 표시.
* 연계 서버(솔루션)
  * 데이터 송/수신
  * 데이터 암/복호화
  * 데이터 변환 / 매핑
  * 응답 처리
  * 완료 처리

## 인터페이스 상세 설계

* 직접 연계 방식
  * 중간 매개체가 없어 연계 처리속도가 빠르고 구현이 단순
  * 개발 비용 저렴
  * 송신 시스템과 수신 시스템 간의 결합도가 높아서 시스템 변경 시 민감
  * 보안을 위한 암/복호화 처리와 비즈니스 로직 구현을 인터페이스 별로 작성
  * 전사 시스템 인터페이스에 대한 통합 환경 구축이 어려움
* 간접 연계 방식
  * 송 * 수신 처리 및 현황을 모니터링하고 통제하는 연계 서버를 활용하는 방식
  * 서로 다른 네트워크와 포로토콜 등 다양한 환경을 갖는 시스템들을 연계하고 통합 관리할 수 있음
  * 인터페이스 변경 시에도 유연한 대처가 가능

### 송*수신 연계 기술

* DB 링크
  * 데이터베이스에서 제공하는 DB 객체를 이용
  * 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
  * 테이블명@DBLink명
* DB 연결
  * 수신 시스템의 WAS 에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀명을 이용
  * 송신 시스템의 Data Source = DB COnnection Pool 이름
* API / OPEN API
  * API명, 입출력 파라미터 벙보가 필요함.

### 통신 유형

* 실시간
  * 단방향
    * 데이터를 이용하고자 하는 시스템에서 거래를 요청하는 방식
    * 데이터를 전송하는 상대 시스템의 응답이 필요 없는 업무에 사용
    * 실시간 File, 실시간 DB 연계에도 이용
  * 양방향
    * 시스템 간의 거래를 상호 요청
    * 응답이 필요할 때
  * Sync
    * 데이터를 이용하고자 하는 시스템에서 거래 요청을 하고 응답이 올 때까지 대기하는 방식
    * 속도가 빠를 경우 사용
  * 비동기
    * 거래를 요청하는 서비스와 응답을 받아 처리하는 서비스가 분리되는 구조
    * 요청을 보내고 다른 작업을 하다가 데이터가 준비되었따는 신호르르 받으면 다시 처리
  * 지연(Deferred) 처리
    * 비동기, 단방향 유형과유사
    * 순차 처리 및 지연처리가 필요할 때
* 배치
  * DB/File 거래
    * 정해진 시간에 통신을 수행된느 방식
    * 연계 스케줄러에 의해 구동되는 이벤트 방식과 타이머에 의한 방식 존재

### 미들웨어 솔루션

* 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어이다.

* 서로 다른 프로토콜이나 시스템 운영체제, 데이터베이스와 애플리케이션 간에 통신을 지원해주는 소프트웨어를 의미한다.

#### 미들웨어 솔루션 유형

* DB 미들웨어
* 원격 프로시저 호출(Remote Procedure Call)
  * 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식
* 메시지 지향(Message-Oriented-Middleware)
  * 메시지 기반의 비동기형 메시지 전달 방식
  * 이기종 분산 DB 시스템의 데이터 동기르 위하여 사용
* 트랜잭션 처리 모니터
  * 온라인 업무에서 트랜잭션을 처리, 감시하는 미들웨어
  * 분산 트랜잭션을 처리하기 위한 미들웨어
* 레거시웨어
  * 기존의 애플리케이션이나 DB 기반에 새로운 업데이트된 기능을 덧붙이고자 할 때
* 객체 기반
  * 각기 다양한 기반으로 구축된 컴퓨터 간의 프로그램과 데이터의 교 환 및 변환 용이화
* WAS
  * 서버계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종시스템과의 애플리케이션 연동을 지원하는 미들웨어
  * HTTP 세션 처리를 위한 웹 서버 기능 뿐만 아니라, 민감한 기업 업무까지 처리 가능



### EAI와 ESB

* EAI(Enterprise Application Intergration)
  * 기업 내 각종 플랫폼 및 애플리케이션 간의 상호 연동이 가능해지도록 통합하는 솔루션
  * 동일한 플랫폼으로 커뮤니케이션 하는 것을 목적
  * 대상 시스템에 비표준 어뎁터를 배포하여 통합한다.
  * 집중형 토폴로지
  * 어댑터 브로커 메시지 큐
    * 어댑터 : 연결 장치
    * 브로커 : 시스템 상호 간 데이터가 전송될 때, 데이터 포맷과 코드를 변환하는 솔루션
    * 메시지 큐 : 비동기 메시지를 사용하는 다른 응용프로그램 사이에서 데이터를 송수신하는 기술
  * 단단한 통합
  * 기업 내부망
* ESB(Enterprise Service Bus)
  * 기업에서 운영되는 서로 다른 플래솜 및 플리케이션 관리 운영
  * 서비스 중심의 통합
  * 표준 API로 통합
  * 분상형 토폴로지
  * 웹 서비스, 지능형 라우터, 포맷 변환, 개방형 표준
  * 느슨한 통합
  * 기업 외부 채널망

# 소프트웨어 개발

## 데이터 입출력 구현

* 자료 구조
  * 컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조
  * 선형 구조
    * 리스트, 스택, 큐, 데크
  * 비선형 구 조
    * 비연속적 연결
    * 트리, 그래프
  * 노드
    * 데이터 저장 부분과 포인터 부분으로 구성된 저장 공간
  * 큐
    * 데이터를 꺼내는 쪽에서 가장 가까운 데이터 : Front
    * 넣는 쪽에서 가장 가까운 데이터 : Rear
  * 트리
    * Depth
      * 루트 노드에서 특정 노드로 도달하기 위한 간선의 수
    * 차수
      * 특정 노드에 연결된 자식의 수
    * 전위 중위 후위 순회의 기준
      * 루트 노드의 방문 우선 순위
      * 전위 : 가장 먼저
      * 중위 : 가운데
      * 후위:  가장 나중에
      * 기본적으로 왼쪽에서 오른쪽으로 방문하는 것은 같다.
      * 순회 != 방문
    * 이진 트리
      * 차수가 2 이하인 노드로 구성
      * 완전 이진 트리
        * 마지막 레벨을 제외하고 노드가 채워진 트리
  * 그래프
    * 사이클
      * 동일 정점에서 시작과 끝이 이어지는 경로
  * 논리 데이터 저장소
    * 개체
      * 관리할 대상이 되는 실체
    * 속성
      * 관리할 정보의 구체적 항목
    * 관계
      * 개체 간의 대응 관계

## 물리 데이터 저장소

* 물리 데이터 저장소는 논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려하여 데이터 베이스 저장 구조(물리 데이터 모델)로 변환하기 위한 데이터 저장소이다.
  1. 단위 개체 -> 테이블
     1. 일반적으로 테이블과 개체 명칭을 동일하게 하는 것을 권고
  2. 속성 -> 컬럼
     1. 컬럼 명칭은 짧을수록 좋다.
  3. UID -> 기본 키
     1. 개체의 UID에 해당하는 모든 속성에 대해 기본 키로 선언
     2. Not null, unique 제약 조건 추가
     3. 관계에 의한 외래 키가 기본 키에 포함 될 수 있음
  4. 관계 -> 외래 키로 변환
     1. 자신의 기본 키는 외래 키로 정의(순환 관계에서)
  5. 컬럼 유형과 길이 정의
  6. 반 정규화 수행
     1. 테이블 통합
        1. 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능 향상
        2. 슈퍼타입/서브타입 테이블 통합 -> 성능 향상
     2. 테이블 분할
        1. 파티셔닝 - 테이블을 수직 또는 수평으로 분할
           1. 수평 분할 
              1. 테이블 분할에 레코드를 기준으로 활용
           2. 수직 분할
              1. 하나의 테이블이 가지는 컬럼의 개수가 증가하는 경우 활용
              2. 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안 적용 필요 속성 분할
     3. 중복 테이블 추가
        1. 집계함수를 효과적으로 수행하기 위한 별도의 통계 테이블 / 중복 테이블 추가
           1. 집계 테이블 추가
           2. 진행 테이블 추가
              1. 이력 관리 목적
              2. 적절한 데이터 양의 유지를 위한 기본키 설정 필요
           3. 특정 부분만 포함하는 테이블 추가
              1. 데이터가 많은 테이블의 특정 부분만 따로 떼서 테이블 생성
     4. 컬럼 중복화
        1. 조인 성능 향상을 위한 중복 허용

### 테이블 제약 조건

* 삭제 제약 조건
  * 연쇄
    * 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 삭제
  * 제한
    * 참조한 테이블에 있는 외부 키에 없는 것만 삭제 가능
  * 무효
    * 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수장
* 갱신 제약 조건
  * 연쇄
    * 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 수정
  * 제한
    * 참조한 테이블에 있는 외부 키에 없는 것만 수정 가능
  * 무효(Nullify)
    * 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정

### Index 설계

* 분포도(Selectivity)
  * 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도이다.
  * 10~15% 이내가 좋다.
  * 조회 및 출력 조건으로 사용되는 컬럼인 경우 적용.
  * 인덱스 자동생성 기본 키와 Unique 키의 제약조건을 사용할 경우 적용.
* 인덱스 컬럼 선정
  * 분포도가 좋은 컬럼은 단독적으로 생성한다.
  * 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성한다.
  * 결합 인덱스는 구성되는 컬럼 순서 선정(사용 빈도, 유일성, 정렬 등)에 유의한다.
* 고려사항
  * 지나치게 많은 인덱스는 overhead로 작용한다.
  * 인덱스는 추가적인 저장 공간이 필요하다.
  * 넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있다.

### View 설계

* 뷰 속성

* |       속성        | 설명                                        |
  | :---------------: | ------------------------------------------- |
  |      REPLACE      | 뷰가 이미 존재하는 경우 재생성              |
  |       FORCE       | 기본 테이블의 존재 여부에 관계 없이 뷰 생성 |
  |      NOFORCE      | 기본 테이블이 존재할 때만 뷰 생성           |
  | WITH CHECK OPTION | 서브 쿼리 내의 조건을 만족하는 행만 변경    |
  |  WITH READ ONLY   | 데이터 조작어 작업 불가                     |

### 클러스터 설계

* 인덱스의 단점을 해결한 기법, 분포도가 넓을 수록 유리하다.
* 엑세스 기법이 아니라 엑세스 효율 향상을 위한 물리적 저장 기법이다.
* 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.
* 대량의 범위를 자주 엑세스 하는 경우 사용
* 인덱스를 사용하기에 부담되는 넓은 분포도에 활용
* 여러 개의 테이블이 빈번하게 조인을 일으킬때

* 고려사항
  * 검색 효율만 높여준다.(입력, 수정, 삭제 시 부하 증가)
  * UNION, DISTINCT, ORDER BY, GROUP BY가 빈번한 컬럼이면 검토 대상
  * 수정이 자주 발생하지 않는 컬럼은 검토 대상
  * 처리 범위가 넓어서 문제일 경우 
    * 단일 테이블 클러스터링 사용
  * 조인이 많을 경우
    * 다중 테이블 클러스터링

### 파티션 설계

| 종류             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 범위 분할(Range) | 분할 키값이 범위 내에 있는지 여부를 구분하는 분할 기법       |
| 해시 분할(Hash)  | 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정하는 분할 기법 |
| 목록 분할(List)  | 값 목록에 파티션을 할당하고 분할 키값을 그 목록에 맞게 분할하는 기법 |
| 조합 분할        | 범위 분할, 해시 분할, 목록 분할 중 2개 이상의 분할 기법 결정 |

* 장점
  * 성능 향상
    * 데이터 엑세스 범위를 줄여서
  * 가용성 향상
    * 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상
  * 백업 가능
    * 분할 영역을 독립적으로 백업하고 복구 가능
  * 경합 감소
    * 디스크 스트라이핑으로 입출력 성능 향상
      * 성능 향상을 위해 데이터를 1개 이상의 디스크 드라이브에 저장하여 드라이브를 병렬로 사용할 수 있는 기술이다.

### 디스크 구성 설계

* 업무량이 집중되어 있는 디스크를 분리하여 설계한다.
* 입출력 경합을 최소화하여 데이터의 접근 성능을 향상시킨다.
* 디스크 구성에 따라 테이블 스페이스 개수와 사이즈 등을 결정한다.
* 파티션 수행 테이블은 별도로 분류한다.

## ORM 프레임워크

* 관계형 데이터베이스와 객체지향 프로그래밍 언어 간 호환되지 않는 데이터를 변환하는 프로그래밍 기법.
* 객체지향 언어에서 사용하는 객체를 관계형 데이터베이스로 변환하여 테이블을 구성
* SQL Mapping(MyBatis) vs OR Mapping(Hibernate)
* 매핑 기법
  * 객체 -> 테이블
  * 속성 -> 컬럼
  * 오퍼레이션 -> 프로시저, 함수
* 절차
  * 인스턴스 -> 테이블의 레코드
  * 인스턴스의 애트리뷰트 -> 테이블 컬럼
  * 클래스 간 관계(Association, Aggregation, Generalization) -> 테이블 간 관계

* 종류

  | 구분      | 부분적 ORM                        | 완전 ORM                    |
  | --------- | --------------------------------- | --------------------------- |
  | 개요      | SQL을 특정 이름으로 정의하여 사용 | 내부 엔진에서 SQL 자동 생성 |
  | 매퍼 사용 | SQL Mapper                        | Object Relation Mapper      |
  | 방법      | MyBatis, iBatis                   | Hibernate                   |
  | 장점      | 데이터 전송 방식의 효율성         | 효율적인 매핑 기법          |

  ## 트렌젝션 인터페이스

  * 트랜잭션
    * 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위이다.
  * 트랜잭션 인터페이스는 데이터베이스 트랜잭션의 입출력과 기능 형태를 정의한 인터페이스이다.
  * 특징
    * 원자성
      * 트랜잭션 연산을 데이터베이스 모두에 반영 또는 반영하지 말아야 함.
    * 일관성
      * 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지
    * 격리성
      * 둘 이상의 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭 불가
    * 영속성
      * 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨.
  * 트랜잭션 인터페이스는 보통 프로그래밍 언어로 구현된다.

## 데이터 조작 프로시저 작성

### 프로시저

* 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 **쿼리의 집합** 이다.
* 데이터베이스 내부에 저장되고 일정한 조건이 되면 자동으로 수행된다.(외부 입력, 특정시간 등)

## 통합 구현

### 단일 모 듈

* 단일 모듈 구현의 원리
  * 정보 은닉
  * 분할과 정복
  * 데이터 추상화
    * 각 모듈 자료 구조를 액세스하고 수정하는 자료 구조의 표현 내역을 은폐
  * 모듈 독립성
    * 낮은 결합도와 높은 응집도
* 환경 변수
  * 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임

* 재사용 종류
  * 재공학
    * 기존 소프트웨어를 버리지 않고 기능을 개선시키거나 기능을 새로운 소프트웨어로 재활용하는 재사용 기법
    * 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세 오류 억제
  * 역공학
    * SW에 대한 디버깅, 디컴파일 등의 분석을 통해 기존 제품에 구현된 구조, 원리, 알고리즘 등을 역으로 분석하여 재구성하는 기법
  * 재개발
    * 기존 시스템 내용을 참조하여 완전히 새로운 시스템을 개발, 기존 시스템에 새로운 기능 추가, 기존 시스템의 기능 변경

### 단위 모듈 테스트

* 개별적인 코드단위가 예상대로 작동하는지 확인
* 종류
  * 블랙박스 테스트
    * 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능 테스트)
    * 소프트웨어 특징, 요구사항, 설계 명세서 등에 초점
    * 명세 기반 테스트
  * 화이트박스 테스트
    * 모듈 내부의 소스를 보 면서 수행하는 테스트
    * 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 수행
    * 구조 기반 테스트
  * 메서드 기반 테스트
    * 단위 모듈 외부에 공개된 메서드 기반 테스트
    * 메서드에 서로 다른 파라미터 값을 호출하면서 테스트를 수행
  * 화면 기반 테스트
    * 화면에 직접 데이터를 입력하여 테스트를 수행
    * 화면에 연계된 서비스, 비즈니스 컴포넌트 및 공통 컴포넌트를 한꺼번에 단위 모듈 테스트에 참여
    * 사용자 시나리오 기반으로 참여 가능한 장점
* 컴포넌트
  * 특정한 기능을 수행하기 위해 독립적으로 개발되어 보급하고, 다른 부품과 조립되어 응용시스템을 구축하기 위해 사용되는 소프트웨어 프로그램이다. 
  * 모듈과의 차이점
    * 컴포넌트는 런타임에 독립적으로 배포되고 실행되는 단위(서버 1개, 클라이언트 5개)
    * 모듈은 정적인 구조(서버, 클라이언트)



### 형상 관리 도구의 기능

* 체크인
  * 개발자가 수정한 소스를 형상 관리 저장소로 업로드 하는 기능
* 체크아웃
  * 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드 받는 기능
* 커밋
  * 개발자가 소스를 형상 관리 저장소에 업로드 후 최종적으로 업데이트 되었을 때 형상 관리 서버에 반영하도록 하는 기능

### CVS(Concurrent Versions System)

* 중앙 집중형 서버 자장소
* 커밋 실패 등의 롤백 기능 미지원
* 일반 문서 중심

### SVN(Subversion)

* 중앙 집중형 클라이언트 - 서버 방식
* CVS 보완 -> CVS와 유사
* 바이너리 문서도 형상 관리 가능
* 롤백 지원
* 디렉토리 파일 이동 자유
* 속도
* Gzip 압축
* Trunk, Branch, Tag가 모두 물리적 저장 위치 점유
* 잦은 커밋으로 리비전 번호 크게 증가
* 개별 개발자만의 개발 이력 가질 수 없음

### Git

* 분산형 방식
* 각 PC에 스스로 완전한 저장소 구성, 필요에 따라 중앙 집중형으로 운영
* 한번에 diff 명령어를 통한 변경사항을 보기 어려움

## 제품 소프트웨어 패키징

### 애플리케이션 패키징

* 개발이 완료된 제품 소프트웨어를 배포하고, 설치할 수 있도록 고객에게 전달하기 위한 형태로 제작하고, 설치와 사용에 필요한 제반 내용을 포함하는 메뉴얼을 작성하는 활동이다.
* 사용자 중심 진행
  * 사용자 실행 환경을 우선적으로 고려
* 버전 관리 및 릴리즈 노트를 통해 고객의 편의성 강화

|        고려사항         | 설명                                                         |
| :---------------------: | ------------------------------------------------------------ |
| 사용자 시스템 환경 정의 | CPU, 운영체제, 메모리 등의 수행 최소 환경                    |
|         UI 제공         | UI 제공, 메뉴얼을 일치 시켜 패키징 작업 수행                 |
| 관리 서비스 형태로 제공 | 하드웨어와 함께 통합 적용할 수 있도록 패키징을 관리 서비스 형태로 제공 |
| 변경 및 개선 관리 고려  | 다양한 사용자들의 요구 사항 반영                             |

### 애플리케이션 패키징 프로세스

* 기능 식별
  * 입출력 데이터 식별
  * 데이터 흐름 식별
  * 기능 단위 및 출력에 대한 상세 정의
* 모듈화
  * 결합도(연관성)와 응집도(독립성) 식별
* 빌드 진행
* 사용자 환경 분석
  * 최소 사용자 환경 사전 정의
  * 모듈 단위의 사용자 환경 테스트 수행
* 적용 시험
  * 사용자 환경에서의 패키징 적용 시험
* 변경 개선
  * 변경점 도출
  * 최소 사용자 환경에서 서비스 가능한 수준의 개선
  * 개선 버전 재배포

### 애플리케이션 배포 도구

* 기술요소
  * 암호화
    * 콘텐츠 및 라이선스를 암호화하고, 전자서명을 할 수 있는 기술
  * 키 관리
    * 암호화한 키에 대한 저장 및 배포 기술(중앙집중형, vs 분산형)
  * 식별 기술
    * DOI, URI
  * 저작권 표현
    * 라이선스의 내용 표현 기술
      * ex) XrML/MPEG-21
  * 암호화 파일 생성
  * 정책 관리
    * 라이선스 발급 및 사용에 대한 정책표현 및 관리기술
      * ex) XML, 콘텐츠 관리 시스템(CMS)
  * 크랙 방지
    * 크랙에 의한 콘텐츠 사용 방지 기술
      * 난독화, Secure DB
      * 크랙
        * 소프트웨어를 수정하여 소프트웨어 복사 방지나 소프트웨어 조작 보호 등을 비활성화하거나 제거하는 일이다.
  * 인증
    * 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술
      * 사용자/장비 인증, SSO

### 애플리케이션 배포 도구 세부

* 공개키 기반 구조(PKI)
  * 공개키 암호 방식 기준으로 디지털 인증서를 활용
* 대칭 및 비대칭 암호화
  * 대칭 암호화는 해독을 위해 동일한 키 사용
  * 비대칭 암호화는 해동할 때와 암호화할 때 서로 다른 키
* 전자 서명
  * 서명자를 확인하고 서명자가 당해 전자문서에 서명했다는 사실을 나타내기 위해 특정 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보
* DOI(Digital Object Identifier)
  * 디지털 저작물에 특정한 번호를 부여하는 바코드 시스템
  * 저작권 보호 및 위치 추적
* XrML(eXtensible Right Markup Language)
  * 디지털 콘텐츠, 웹 서비스 권리 조건을 표현한 XML 기반의 마크업 언어

* MPEG-21
  * 멀티미디어 관련 요소 기술들이 통일된 형태로 상호 운용성을 보장하는 표준 규격
* 마크업 언어
  * 태그는 원래 텍스트와는 별도로 원고의 규정 부호와 주석을 표현하기 위한 수단이었으나 용도가 점차 확장되어 문서의 구조를 표현하는 역할을 하게 되었고, 이러한 태그 방법의 체계가 마크업 언어이다.
* CMS
  * 각종 콘텐츠를 생성, 수집, 관리, 배급하는 콘텐츠 생산에서 활용, 폐기까지 전공급 과정을 관리하는 기술
* 코드 난독화
  * 역공학을 통한 공격을 막기 위해서 프로그램의 소스 코드를 알아보기 힘든 형태로 기술
* Secure Db
  * 커널 암호화 방식으로 db 파일을 직접 암호화하고, 접근 제어와 감사 기록 기능이 추가된 데이터베이스 보안 강화 기술
* SSO
  * Single Sign On
  * 한번의 시스템 인증을 통하여 여러 정보 시스템에 재인증 절차 없이 접근할 수 있는 통합 로그인 기술

### DRM

* Digital Rights Management
  * 디지털 콘텐츠에 대한 권리정보를 지정하고 암호화 기술을 이용하여 허가된 사용자의 범위 내에서 콘텐츠의 이용
* 허가 받은 사용자는 별도의 비밀키를 이용하여 대상 콘텐츠를 복호화하고 허가된 권한으로 사용 가능
  * 동작 방식
    1. 라이선스 등록
       1. 클리어링 하우스에 라이선스 등록을 하면서 동시에 유통시스템 컨텐츠를 등록
    2. 라이선스 요청
       1. 콘텐츠 소비자가 유통시스템으로 라이선스 요청
    3. 라이선스 요청
       1. 유통 시스템에서 클리어링 하우스를 통해서 라이선스를 요청
    4. 요금 지불
       1. 콘텐츠 소비자가 요금 지불
    5. 라이선스 발급
       1. 클리어링 하우슬를 통해서 라이선스 발급
    6. 컨텐츠 다운로드
       1. 그 이후에 콘텐츠 소비자가 다운로드 할 수 있음.

### 국제 표준 제품 품질 특성

* ISO/IEC 9126
  * 기능성
    * 소프트웨어가 특정 조건에서 사용될 때 명시된 요구와 내재된 요구를 만족하는 기능을 제공하는 소프트웨어 제품의 능력
  * 신뢰성
    * 명세된 조건에서 사용될 때 성능 수준을 유지할 수 있는 소프트웽,ㅓ제품의 능력
    * 옳고 일관된 결과
    * 주어진 시간 주어진 기능
  * 사용성
    * 사용자에 의해 이해되고, 학습되고, 사용되고 선호될 수 있는가
  * 효율성
    * 자원의 양에 따라 요구된 성능을 제공하는 능력
  * 유지보수성
    * 소프트웨어제품이 변경되는 능력
  * 이식성
    * 한 환경에서 다른 환경으로 전이될 수 있는 소프트웨어 제품의 능력
* ISO/IEC 14598
  * 반복성
    * 특정 제품을 동일 평가자가 동일 사양으로 평가하면 동일한 결과가 나와야 한다.
  * 재현성
    * 특정 제품을 다른 평가자가 동일 사양을 평가하면 유사한 결과
  * 공정성
  * 객관성
* 국제 프로세스품질 표준
  * 9001
    * 공급자와 구매자 각각의 관리책임
  * 12207
    * 획득, 공급, 개발, 운영, 유지 보수 관리
  * 15504
    * 프로세스 평가 및 개선
  * CMMi
    * 단계별 표현
      * 조직의 전체적인 성숙도 확인
    * 연속적 표현
      * 능력 수준을 이용하여 조직의 성숙도 확인
      * 4개의 범주로 그룹화
* ISO/IEC 25000
  * 품질 평가 통합 모델
  * 4+1 구조

### 소프트웨어 공학의 기본 원칙

* 개념
  * 소프트웨어는 하드웨어를 동작시켜 사용자가 작업을 편리하게 수행하도록 하는 프로그램 및 자료구조이다.
* 소프트웨어 위기를 극복하기 위한 방안으로 연구된 학문
  * 브룩스의 법칙
    * "지체되는 소프트웨어 개발 프로젝트에 인력을 추가하는 것은 개발을 늦출 뿐이다."
  * 파레토 법칙
    * 20%의 모듈에서 80%의 결함이 발견된다.
  * 롱테일(파레토와 반대)
    * 사소해 보이는 80%의 다수가 20%의 소수 핵심보다도 뛰어난 가치를 창출해낸다.

## 제품 소프트웨어 버전 관리

### 버전 관리 도구

* 공유 폴더 방식
  * RCS(Revision Control System -> 한 사람만 소스 파일 수정 가능), SCCS
    * 개발 완료 파일을 약속된 위치의 공유 폴더에 복사
    * 개발자 한 명이 매일 공유 폴더의 파일을 자기 PC로 복사하고 컴파일하여 에러 확인과 동작 여붛 ㅗ가인

* 클라이언트/서버 방식
  * CVS, SVN
  * 중앙에 버전 관리 시스템으 항상 동작
  * 서로 다른 개발자가 같은 파일을 작업했을 때 경고 메시지 출력
* 분산 저장소 방식
  * Git, Bitkeeper
* 백업의 유형
  * 전체 백업
    * 백업받고자 하는 데이터 전체에 대해 백업
  * 차등 백업
    * 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식
  * 증분 백업
    * 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업
* Bundle
  * 개념상 관련된 파일들을 모두 하나로 묶어주는 꾸러미로 애플리케이션, 프레임워크나, 플러그인의 실행 파일을 의미한다.

### 빌드 자동화 도구

* 빌드
  * 소프트웨어를 생성하고 테스트하고 검사하여 배포하기 위해 수행하는 행위의 집합이다.
* 빌드 자동화 도구
  * 제품 소프트웨어 실행 파일을 자동화하기 위해서 저장소에 있는 소스를 자동으로 읽어서 빌드한 후 테스트하고 검사하여 실행파일을 만드는 도구이다.
  * 지속적인 통합과도 연관
    * 지속해서 품질제어를 적용하는 프로세스를 실행하는 기법으로, 소프트웨어 릴리스 프로세스 중 빌드 또는 통합 단계에 적용된다.
* 빌드 자동화 프로세스
  1. 컴파일
  2. 패키징(바이너리 -> 배포 형태)
  3. 단위 테스트(커버리지 포함)
  4. 정적 분석
  5. 리포팅
  6. 배포(테스트 서버에)
  7. 최종 빌드
* 빌드 자동화 구성요소
  * 형상 관리 서버에 저장된 소스 코드를 주기적으로 가져와서 컴파일, 단위 테스트, 코드 검사 등의 과정을 수행하며 신규 또는 수정된 소스 코드가 결함이 있는지의 여부를 지속적으로 검증한다.
  * 검증 결과는 이메일 등의 피드백을 통해 개발자들에게 전달된다.
  * CI 서버
    * 빌드 프로세스를 관리하는 서버
    * Jenkins, Hudson
  * SCM
    * SVG, Git
  * 빌드 도구
    * 컴파일, 테스트, 정적 분석 등을 통해 동작 가능한 소프트웨어 생성
    * Ant, Maven
  * 테스트 도구
    * 작성된 테스트 코드에 따라 자동으로 테스트를 수행해주는 도구로, 빌드 도구의 스크립트에서 실행
    * JUnit,Selenium
  * 테스트 커버리지 도구
    * 테스트 코드가 대상 소스 코 드에 대해 어느 정도 커버하는지 분석하는 도구
    * Emma
  * 인스펙션 도구
    * 프로그램을 실행하지 않고, 소스 코드 자체로 품질을 판단할 수 있는 정적 분석 도구
    * 코딩 표준 준수 검사, 코드 메트릭 측정, 중복 코드 검사, 코드 인스펙션 검사
    * 코드 인스펙션
      * 개발 표준에 위배되었거나, 코드가 중복 또는 작성 규칙에 맞지 않거나 잘못 구현된 부분을 수정하는 ㅈ가업
* 빌드 자동화 도구의 기능
  * 코드 컴파일
    * 테스트 포함 코드 컴파일
  * 컴포넌트 패키징
    * jar파일이나 exe파일 같은 배포할 수 있는 컴포넌트를 묶는 작업
  * 파일 조작
    * 파일과 디렉토리를 만들고, 복사 및 지우는 작업
  * 개발 테스트 실행
  * 버전 관리 도구 통합
  * 문서 생성
    * API 문서 생성
  * 배포 기능
    * 테스트 서버 배포 기능
  * 코드 품질 분석

* Jenkins
  * 서블릿 컨테이너 기반
    * 서블릿
      * 서블릿 컨테이너 위에서 작동하는 웹 서비스용 자바 인터페이스의 객체(애플리케이션)이다.
    * 서블릿 컨테이너
      * 서블릿을 관리하고 동작시킬 수 있는 환경을 제공하는 서버 프로그램
  * Jenkins.war 파일로 제공
    * java -jar jenkins.war 명령어로 설치 가능
* Gradle
  * 안드로이드 공식 자동화
  * 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.

## 애플리케이션 테스트 관리

## 테스트 케이스

* 입력값, 실행 조건, 예상된 결과의 집합

### 테스트 오라클

* 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 방법
* 참 오라클
  * 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생하는 오류를 모두 검출하는 오라클
* 샘플링 오라클
  * 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클
* 휴리스틱 오라클
  * 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클
* 일관성 검사 오라클
  * 애플리케이션 변경이 있을 때 수행 전과 후의 결과값이 동일한지 확인하는 오라클

### 테스트 레벨

* 함꼐 편성되고 관리되는 테스트 활동의 그룹이다.
* 테스트 레벨은 프로젝트에서 책임과 연관되어 있다.
* 각각의 테스트 레벨은 서로 독립적이다.

* 종류
  * 단위 테스트
    * 사용자 요구사항에 대한 단위 모듈, 서브 루틴 등을 테스트 하는 단계 
      * 인터페이스 테스트
      * 자료 구조 테스트
      * 실행 경로 테스트
      * 오류 처리 테스트
    * 모듈과 컴포넌트 중심
    * 인터페이스, 외부적 I,O, 독립적 기초 경로
    * 주로 구조 기반 테스트(화이트박스)
  * 통합 테스트
    * 단위 테스트를 통과한 컴포넌트 간의 인터페이스를 테스트 하는 단계
      * 빅뱅 테스트
      * 상향/하향식 테스트
  * 시스템 테스트
    * 개발 프로젝트 차원에서 정의된 전체 시스템 또는 제품의 동작에 대해 테스트
    * 비기능/기능 요구사항 테스트
    * 컴퓨터 시스템을 완벽하게 검사하기 위한 목적
    * 기능적 요구사항 테스트
      * 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트
    * 비기능적 요구사항
      * 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 네비게이션 등의 구조적 요소에 대한 화이트박스 테스트
  * 인수 테스트
    * 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계
      * 사용자 인수 테스트
        * 비즈니스 사용자가 시스템 사용의 적절성 여부 확인
      * 운영상의 인수 테스트
        * 시스템 관리자가 시스템 인수 시 수행하는 테스트 활동으로 
        * 백업/복원 시스템
        * 재해 복구
        * 사용자 관리
        * 정기 점검
      * 계약 인수 테스트
        * 계약상의 인수/검수 조건을 준수하는가
      * 규정 인수 테스트
        * 정부 지침, 법규, 규정 등이 맞는가
      * 알파 테스트
        * 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트
      * 베타 테스트
        * 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트

### 테스트 지식 쳬게

|    분류     | 설명                                              | 유형                                           |
| :---------: | ------------------------------------------------- | ---------------------------------------------- |
| 정적 테스트 | 테스트 대상을 실행 x, 구조를 분석하여 논리성 검증 | 리뷰(동료 검토, 워크스루, 인스펙션), 정적 분석 |
| 동적 테스트 | 실행해서 결함 검출                                | 화이트박스, 블랙박스, 경험 기반                |

* 화이트박스 테스트 유형
  * 구문 커버리지(Statement Coverage)
    * 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
    * 구문 실행 개수로 계산
  * 결정,선택,분기 커버리지(Decision, Dracnh)
    * 결정 포인트 내이ㅡ **전체** 조건식이 적어도 한 번은 참과 거짓 결과를 수행하는 테스트 커버리지
  * 조건 커버리지
    * 각 **개별** 조건식이 적어도 한 번은 참과 거짓
  * 조건 / 결정 커버리지
    * 전체 조건식 + 개별 조건식
  * 변경 조건/ 결정 커버리지
    * 개별 조건식이 독립적으로 전체 조건식에 영향을 주도록 한다.
  * 다중 조건
    * 모든 개별 조건식의 모든 가능한 조합 100% 보장
  * 기본 경로
    * 수행 가능한 모든 경로 테스트
  * 제어 흐름
    * 제어구조를 그래프 형태로 나타내어 내부 로직 테스트
  * 데이터 흐름
    * 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프로 테스트
* 블랙박스
  * 동등 분할
    * 입력 데이터 영역을 유효/무효 값 그룹핑
  * 경곗값
    * 등가분할 후 경곗값 부분에서 오류 테스트
  * 결정 테이블
    * 요구사항의 논리와 발생 조건을 테이블 형ㅇ태로 나열하여 모든 조건과 행위를 조합하여 테스트
  * 상태전이
    * 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행
  * 유스케이스
    * 프로세스 흐름 기반으로 테스트 케이스 명세화 및 수행
  * 분류 트리
    * SW의 일부 또는 전체를 트리 구조로 분석 및 표현
  * 페어와이즈
    * 테스트 데이터 간의 최소 한 번씩을 조합
  * 원인-결과
    * 입력 데이터간의 관계 및 출력에 미치는 영향 분석
    * 효용성이 높은 테스트 케이스 선정 및 테스트
  * 비교
    * 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과가 나오는가.
* 테스트 시각에 따른 분류
  * 검증
    * 개발 과정
    * 개발자 혹은 시험자 관점
  * 확인
    * 결과
    * 제품이 제대로 동작하는가
    * 최종 사용자 시각
* 목적에 따른 분류
  * 회복
    * 고의로 실패 유도, 정상적 복귀 여부 테스트
  * 안전
    * 소스 코드 내의 보안적인 결함 미리 점검
  * 성능
    * 사용자의 이벤트에 시스템이 응답하는 시간, 반응 속도 등
  * 구조
    * 내부 논리 경로, 소스 코드 복잡도
  * 회귀
    * 오류를 제거하거나 수정한 시스템에에서 사용
    * 새로 유입된 오류가 없는지 일종의 반복 테스트
  * 병행
    * 변경된 시스템과 새로운 시스템에 동일한 데이터 입력후 결과 비교

* 테스팅은 결함이 없다는 것을 증명할 수는 없다. 
* 결함을 줄이는 활동
* 완벽한 테스팅 불가
* 개발 초기에 테스팅 시작
  * 테스팅 결과 단시간 파악
  * 기간 단축
  * 재작업 줄이기
  * Snowball Effect
* 결함 집중
  * 파레토 법칙 적용
* 살충제 패러독스
  * 동일한 테스트 케이스에 의한 반복적 테스트 -> 새로운 버그 찾지 못함
  * 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근 필요
* 정황 의존적(상황에 맞게 테스트)
* 오류 - 부재의 궤변
  * 오류가 없다-> 품질이 높다 (X)

## 애플리케이션 통합 테스트

### 결함

* 개발자 오류로 인해 만들어지는 문서 또는 코딩상의 결점

* 에러
  * 결함의 원인
  * 일반적으로 사람에 의해 생성된 실수
* 결함/결점/버그
  * 에러 또는 오류가 원인이 되어 소프트웨어 제품에 포함되어 있는 결함
  * 제거하지 않으면 소프트웨어의 실패나 문제 발생
* 실패/문제
  * 결함이 실행될 때 발생되는 현상

* 장애(Failure)
  * 시스템이 결함으로 인해 사용자가 기대하는 서비스를 제공하지 못하거나 의도하지 않은 동작이 나타나느는 상태

### 테스트 자동화 도구

* 반복적인 테스트 작업을 스크립트 형태로 구현

* 테스트 실행 도구 유형
  * 데이터 주도 접근 방식
    * 데이터를 스프레드시트에 저장, 읽고 실행
    * 동일한 테스트 케이스를 반복해서 실행
  * 키워드 주도 접근 방식
    * 테스트 동작을 나타내는 키워드와 데이터를 스프레드 시트에 저장
    * 키워드를 이용하여 동작 정의, 테일러링 가능
      * 테일러링 : 프로젝트 특성과 필요에 따라 개발 프로세스를 적합한 규모로 가공
* 테스트 장치 구성요소
  * 테스트 드라이버
    * 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트수행 후의 결과를 도출
    * 상향식 테스트에 필요
  * 테스트 스텁(stub)
    * 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
    * 하향식 테스트에 필요
  * 테스트 슈트
    * Test case를 실행환경에 따라 구분해놓은 TestCase의 집합
    * 단, 시나리오 포함 X
  * 테스트 시나리오
    * 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서
    * 하나 또는 여러개의 테스트 케이스 포함할 수 있음
    * 테스트 케이스와 일대 다 관계
  * 테스트 스크립트
    * 테스트 실행 순서 작성
    * 테스트 스텝, 절차서 라고도 불림
  * 목 오브젝트
    * 상황에 예정된 행위르르 수행과 객체.



### 해싱 함수

* 임의의 길이의 데이터를 고정된 길이의 데이터로 해싱하는 함수이다.

|    함수     | 설명                                                         |
| :---------: | ------------------------------------------------------------ |
|   제산법    | 나머지 연산자를 사용하여 테이블 주소를 계산하는 방식         |
|   제곱법    | 레코드 키값을 제곱한 후에 결괏값의 중간 부분에 있는 몇 비트를 선택하여 해시 테이블으 홈 주소로 사용 |
| 숫자 분석법 | 레코디 키를 구성하는 수들이 모든 키들 내에세서 자리 별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택하여 , 홈 주소로 선택 |
|   폴딩법    | 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈주소 |
| 기수 변환법 | 다른 진법으로 간주하고 키를 변환하여 얻는 방식               |
|   무작위    | 난수를 발생시켜 홈 주소 결정                                 |

# 인터페이스 구현

### EAI(Enterprise Application Integration)

* 포인트 투 포인트
  * 중간에 미들웨어를 두지 않고 각각의 애플리케이션 간의 점대점 형태로 연결
* 허브 앤 스포크
  * 단일한 접점의 허브시스템을 통하여 데이터를 중앙 집중식 방식
  * 허브 장애시 전체 장애 발생
* 메시지 버스
  * 애플리케이션 사이 미들웨어(버스)를 두어 연계하는 미들웨어통합 방식
  * 확장성, 대용량 데이터
* 하이브리드
  * 그룹 내에서는 허브 앤 스포크 방식
  * 그룹 밖에서는 버스 방식

### Enterprise Service Bus

* 버스를 중심으로 각각 포로토콜이 호환이 가능하도록 애플리케이션의 통합을 낮은 결합 방식으로 지원



### 시큐어 코딩 가이드

| 적용 대상                | 보안 약점                                                    | 대응 방안                                                    |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 입력 데이터 검증 및 표현 | 프로그램 입력값에 대한 검증 누락, 부적절한 검증, 잘못된 형식 지정 | 유효성 검증 체계 수립, 사용자 실패시 처리 설계 구현          |
| 보안 기능                | 보안 기능의 부적절한 구현                                    | 인증*접근 통제, 권한 관리, 비밀 번호 등의 정책 적절하게 반영되도록 |
| 시간 및 상태             | 거의 동시에 수행 지원하는 병렬 시스템, 하나 이상의프로세스가 동작하는 환경에서 시간 및 상태의 부적절한 관리 | 공유자원의 접근 직렬화, 병렬 실행 가능 프레임워크 사용, 블록문 내에서만 재귀 함수 호출 |
| 에러 처리                | 에러 처리, 불충분한 처리, 에러 메시지에 중요 정보 포함       | 중요 정보 유출 않도록 보안                                   |
| 코드오류                 | 코딩 오류                                                    | 코딩 규칙 도출 -> 검증 가능한 스크립트 구성, 경고 순위 조정  |
| 캡슐화                   | 불충분한 캡슐화 -> 인가되지 않은 사용자에게 데이터 누출      | 디버거 코드 제거와 필수정보 외의 클래스 프라이빗 접근자 지정 |
| API 오용                 | 사용에 반하는 방법으로 API 사용, 보안 취약 API               | API 검출 프로그램                                            |

### 암호화 알고리즘

* 대칭 키
  * 같은 암호 키
  * ARIA 128/192/256, SEED
* 비대칭
  * RSA, ECC, ECDSA
* 해시
  * 해시 값으로 원래 입력값을 찾아낼 수 없는, 일방향 특성
  * SHA-256/384/512, HAS-160

### 중요 인터페이스 데이터의 암호화 전송

* IPSec(IP security)
  * IP 계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안 서비스를 제공하는 터널링 프로토콜
  * 동작 모드는 전송 모드와 터널 모드
  * 주요 프로토콜은 AH, ESP, IKE(키 교환)
* SSL/TLS
  * 전송게층(4),와 응용계층(7)사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜
  * 인증 모드는 익명 모드, 서버 인증 모드, 클라이언트 - 서버 인증 모드가 있음
  * IPSec하고는 다르게 Client와 Server 간에 상호 인증, 암호 방식에 대해 협상을 거치는 특징
  * 특정 암호 기술에 의존하지 않음
  * https://~ 표시형식과 443포트 이용
* S-HTTP
  * 웹상에서 트래픽 암호화, 모든 메시지 암호화 전송
  * http 사용 애플리케이션에서만 적용

## 인터페이스 구현 검증

