# 서버 프로그램 구현

## 개발환경 구축

- 빌드 도구
  - 작성한 코드의 빌드 및 배포를 수행하는 도구
  - 각각의 구성요소와 모듈에 대한 의존성 관리를 지원하는 도구
- 구현 도구
  - 코드의 작서오가 디버깅, 수정
  - 가장 많이 사용
- 테스트 도구
- 형상 관리 도구

### 개발환경 구성요소

- 웹 서버
  - 웹 브라우저의 요청을 받아 HTTP를 통해 웹 브라우저에서요청하는 HTML 문서나 오브젝트(이미지 파일 등)를 전송해주는 서버
- 웹 애플리케이션 서버
  - 사용자에게 동적 서비스 제공하기위해 웹 서버로부터 요청을 받아 데이터 처리 수행
  - 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행
- 데이터베이스 서버
  - 데이터베이스와 이를 관리하는 DBMS를 운영하는 서버
- 파일 서버
  - 파일 저장 하드웨어로 물리 저장 장치를 활용한 서버
  - 대용량 HDD, SSD 등의 장치가 존재
  - AWS S3
- 클라이언트 하드웨어 개발환경
  - 클라이언트 프로그램
    - 설치를 통해 사용자와 커뮤니케이션
    - Visual Basic, C#, Delphi 등으로 개발
  - 웹 브라우저
  - 모바일 앱
    - 모바일 디바이스에서 설치되어 활용
    - App Store, Android Market
  - 모바일 웹
    - 웹 브라우저와 동일한 형태
- 소프트웨어 개발환경

  - 운영체제
    - 하드웨어를 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어
  - 미들웨어
    - 웹 서버, JVM과 같은 개발환경의 구성요소로 활용
  - DBMS
    - 데이터의 저장 및 활용을 위해 설치

- 프레임워크의 특징
  - 모듈화
    - 구현을 인터페이스 뒤에 감춰 모듈화를 강화
    - 설계와 구현 변경에 따르는 영향 최소화
  - 재사용성
    - 여러 애플리케이션에서 반복적으로 사용하는 컴포넌트를 정의
  - 확장성
    - 다형성
  - 제어의 역행
    - 프레임워크 코드가 전체 애플리케이션 처리흐름을 제어
    - 외부의 이벤트에 대해 애플리케이션이 어떤 메서드를 수행해야 할지 결정

## 공통 모듈 구현

- 재사용
  - 함수와 객체 재사용
    - 클래스나 함수 단위로 구현한 코드 재사용
  - 컴포넌트 재사용
    - 컴포넌트 단위로 재사용
    - 컴포넌트의 인터페이스를 통해 통신
  - 애플리케이션 재사용
    - 공통기능을 제공하는 애플리케이션과 기능을 공유하여 재사용
- 코드 재사용

  - 프로그램 이전 버전에서 시작해 다음 버전을 개발하는 작업도 재사용

- 재사용 프로그래밍 기법

  - 객체지향 프로그래밍
  - 제네릭 프로그래밍
  - 자동 프로그래밍
    - 사용자가 설정 변수에 근거한 프로그램 생성
  - 메타 프로그래밍
    - 런타임에 수행해야 할 작업의 일부를 컴파일 타임 동안 수행

- 모듈화의 유형

  - 설계 측면
    - 모듈
      - 연관 기능을 한 부분에 모아놓고 라이브러리 형태로 사용
    - 컴포넌트
      - 바이너리 형태의 재사용 가능한 형태
      - 인터페이스에 의해 로직을 수행할 수 있는 모듈 단위
    - 서비스
      - 기존 컴포넌트보다는 느슨한 결합 형태의 기능을 제공하는 모듈 단윈
  - 구현 측면
    - 함수
      - 커다란 프로그램의 일부 코드로 특정한 작업을 수행하고 상대적으로 다른 코드에 비해 독립적인 모듈
    - 매크로
      - 프로그램의 반복되는 부분을 특정 이름을 부여하고 실행
    - 인라인
      - 프로그램 '구현 시' 반복되는 부분을 특정 이름을 부여하여 실행할 수 있도록 프로그램

  ### 결합도

  - 모듈 '외부'와의 연관도 또는 모듈 간의 상호 의존성

  - 특징

    - 모듈 연관성 없음
      - 서로 다른 상위 모듈에 의해 호출되어 처리상 연관성이 없는 다른 기능을 수행
    - 인터페이스 의존성
      - 자료전달이 인터페이스를 통과하여 인터페이스 복잡성에 의존적
    - 복잡성 감소
    - 파급효과 최소화

  - 유형

    - 내용 결합도
      - 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우
      - 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때
    - 공통 결합도
      - 파라미터가 아닌 모듈 박에 선언되어 있는 **전역 변수**를 참조하고 전역 변수를 갱신하는 식으로 상호작용
        - 전역 변수 : 지역 변수와 다르게 데이터 영역에 저장된다.
    - 외부 결합도
      - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
    - 제어 결합도
      - 어떤 모듈이 다른 모듈으 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우
      - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 사우이 모듈에게 처리 명령을 부여하는 권리 전도현상
    - 스탬프 결합도
      - 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우
    - 자료 결합도
      - 모듈 간의 인터페이스로 전달되는 파라미터를 통해시먼 모듈 간의 상호 작용이 일어나는 경우의 결합도

    ### 응집도

    - 모듈 내부 구성요소간 연관 정도
    - 정보 은닉 개념의 확장개념, 하나의 모듈은 하나의 기능을 수행한다.
    - 특징
      - 유사기능 영역구성
      - 단일 책임할당
      - 함수 간 상호협력
        - 하나의 함수에 많은 기능을 넣지 않고 다른 함수와 협력
    - 유형
      - 우연적 응집도
        - 서로 간에 어떠한 의미 있는 연관 관계또 없는 기능 요소로 구성
        - 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 기능 수행
      - 논리적 응집도
        - 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들이 한 모듈안에서 처리
      - 시간적 응집도
        - 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
      - 절차적 응집도
        - 모듈이 다수 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행
      - 통신적 응집도
        - 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우
      - 순차적 응집도
        - 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
      - 기능적 응집도
        - 모듈 내부의 모든 기능이 단일 목적을 위해 수행되는 경우

### 서버 프로그램 구현

- 보안 취약성
  - 정보시스템에 불법적인 사용자의 접근, 정상적인 서비스를 방해, 중요 데이터 유출,변조 삭제에 대한 위협
- 침투 테스트
  - 전문 해커가 공격자보다 먼저 시스템의 취약점을 찾기 위한 방법
    1. 정찰
       1. 애플레키이션 관련 정보 수집
    2. 탐색
       1. 애플리케이션을 검사하여 보안 위협에 관련된 상세 정보 확인
    3. 접근 권한 획득
       1. 허점을 찾아내어 악성 코드를 삽입하여 데이터에 접근 권한획득
    4. 액세스 유지
       1. 접근 권한을 유지하여 다수의 테스트 수행
    5. 추적 방지
       1. 공격자가 자신의 흔적을 남기지 않도록 로그, 수집된 데이터 등의 접근 이력 모두 제거
- 취약성에 따른 공격기법
  - 서비스 거부(DoS)
    - 무의미한 서비스 요청 등의 반복을 통해 특정 시스템의 가용 자원을 소모시켜 서비스 가용성을 저하
  - 코드 실행
    - 입력 유효성 검사 없이 쉘 명령을 실행하는 취약점을 이용하여 공격자가 원하는 임의 코드가 실행
  - 버퍼 오버플로우
    - 정해진 메모리의 범위를 넘치게 해서 원래의 리턴 주소를 변경시켜 임의의 프로그램이나 함수를 실행
  - 정보 수집
    - 공격 전 서버 또는 시스템의 취약점, 네트워크 경로, 방화벽 설치 유무
  - 권한 상승
    - 악성 프로그램 설치 후 데이터 조회, 변경, 삭제 등을 통한 권한 상승으로 루트 권한 획득
  - SQL 삽입
  - XSS(크로스 사이트 스트립팅)
    - 공격자가 게시판에 악성 스크립트를 작성, 삽입하여 사용자가 그것을 보았을 때 이벤트 발생을 통해 사용자의 쿠키 정보, 개인 정보들을 특정 사이트로 전송
  - 사이트 간 요청 위조 공격(CSRF)
    - 사용자가 자신이 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격기법
  - 디렉터리 접근
    - HTTP 기반의 공격으로 액세스가 제한된 디렉터리에 접근하여, 서버의 루트 디렉터리에서 외부 명령 실행
  - FTP 바운스 공격
    - FTP 서버가 데이터를 전송할 때 목격자가 어디인지 검사하지 않는 문제점을 이용
- API의 종류
  - 윈도우 API
    - 운영체제가 사용하는 API
    - 프로그래밍 언어에서 직접 운영체제와 상호작용
    - 운영체제에 대한 기본 서비스, 고급 서비스, 사용자 인터페이스, 네트워크 서비스, 셸 등 여러 기능 제공
  - 웹 API
    - XML, JSON, SOAP, REST
      - SOAP(Simple Object Access Protocol)
        - 웹 서비스에서 기본적인 메시지를 전달하는 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜이다.

### 배치 프로그램 구현

- 사용자와의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 기법
- 필수 요소
  - 자동화
    - 사용자의 개입 없이 동작(오류 상황 외에는)
  - 안정성
    - 어떤 문제가 생겼는지, 언제 발생했는지 추적 할 수 있어야 함
  - 대용량 데이터
  - 견고성
    - 유효하지 않은 데이터의 경우도 처리해서 비정상적인 동작 중단이 발생하지 않아야 함
  - 성능
    - 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 함
- 유형
  - 이벤트 배치
    - 사전에 정의해 둔 조건 충족시 자동으로 실행
  - 온디맨드 배치
    - 사용자의 명시적 요구가 있을 때마다 실행
  - 정기 배치
    - 정해진 시점(주로 야간)에 정기적으로 실행

# 응용 소프트웨어 기초 기술 활용

## 운영체제 기초 활용

* 운영체제는 크게 인터페이스와 커널의 구조이다.
* 윈도즈
  * 자동 감지 기능 제공
    * 하드웨어를 설치했을 때 필요한 시스템 환경을 운영체제가 자동으로 감지
  * OLE(Object LInking and Embedding)
    * 개체를 현재 작성 중인 문서에 자유롭게 연결 또는 삽입하여 편집할 수 있게 하는 기능
* 리눅스/유닉스
  * 대화식 운영체제 기능
  * 다중 작업
  * 다중 사용자
  * 이식성
    * 90% 이상 C언어로 구성, 시스템 프로그램이 모듈화
  * 계층적 트리 구조 파일 시스템

### 메모리 관리

* 가상 주소 공간은 메모리 관리 장치에 의해서 물리 주소로 변환
* 메모리 관리 장치
  * 메모리 보호, 캐시 관리, 버스 중재
  * 컴퓨터 하드웨어 부품
* 메모리 관리자
  * 기억장치의 어느 부분이 사용중인지 또는 아닌지를 조사하여 프로세스에게 필요할 때마다 기억 장치를 할당 후 회수
  * 실행 파일 심볼의 재배치 주소를 프로세스의 논리 주소로 연결시키는 작업 수행
* 관리 기법
  * 반입(When)
    * 주기억장치에 적재할 다음 프로세스의 반입 시기를 결정하는 기법
    * 요구 반입 기법
      * 다음에 실행할 프로세스가 참조 요구가 있을 경우에 적재
    * 시스템의 요구를 예측하여 미리 메모리에 적재 요구되는 페이지 이외 다른 페이지도 적재
  * 배치(Where)
    * 디스크에 있는 프로세스를 주기억장치에 어느 위치에 저장
    * First Fit
      * 프로세스가 적재될 수 있는 가용 공간 중에서 첫번 째 분할에 할당
    * Best Fit
      * 가장 크기가 비슷한 공간을 선택
    * Worst-fit
      * 가용 공간 중에서 가장 큰 공간에 할당
  * 할당
    * 실행해야 할 프로세스를 주기억장치에 어떤 방법으로 할당
    * 연속 할당 기법
      * 각 프로세스를 주기억장치 공간 내에 인접하게 연속하여 저장
      * 주 기억 장치 내에 인접하게 연속하여 저장
    * 분산 할당 기법
      * 하나의 프로세스를 여러 개의 조각으로 나누어 주 기억장치 공간 내 분산하여 배치
      * 주로 가상기억 장치에 활용
      * 페이징 기법
        * 실제 공간은 페이지 크기와 같은 페이지 프레임으로 나누어 사용
        * 페이지 테이블에서 실제 메모리 기준 주소를 찾고 변위를 더해 물리 메모리 주소 결정
      * 세그멘테이션
        * 가상기억장치 내의 프로세스를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하고 할당
        * 분할 형태가 배열이나 함수와 같은 논리적인 다양한 크기의 가변적인 크기로 관리
        * 계산 시에 크기가 세그먼트 크기가 일정하지 않기 때문에, 테이블에 시작 주소와 세그먼트 크기(limit) 정보가 주어짐.
        * CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트 발생 
  * 교체 기법
    * 어떤 프로세스를 제거할까
    * Swap In / Out
    * FIFO
      * 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래 있던 페이지를 교체
    * LRU(Least Recently Used)
      * 가장 오랫동안 사용되지 않은 페이지를 선택
    * Least Frequently Used
      * 사용한 횟수
    * OPT
      * 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
    * NUR Not used recently
    * SCR(Second Chance Replacement)
      * 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법
  * 메모리 단편화
    * 분할된 주 기억장치에 프로세스를 할당, 반납 과정에서 사용되지 못하고 낭비되는 기억장치가 발생되는 현상
    * 내부 단편화
      * 분할된 공간에 프로세스를 적재한 후 남은 공간
      * 고장 분할 할당 방식 또는 페이징 기법
      * Slab Allocator, 통합, 압축으로 해결
        * 페이지 프레임을 할당받아 공간을 작은 크기로 분할하고 메모리 요청 시 작은 크기로 메모리를 할당 /해제
    * 외부 단편화
      * 할당된 크기가 프로세스 크기보다 작아서 사용하지 못하는 공간
      * 가변 분할 할당 / 세그멘테이션 기법 사용 시 발생
      * 버디 메모리 할당
        * 메모리를 2n 크기로 분할하여 할당
      * 통합
        * 인접한 단편화 영역을 찾아 하나로 통합
      * 압축
        * 메모리의 모든 단편화 영역을 하나로 압축
    * 페이지 기법 문제점
      * 스레싱
        * 어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 실제 처리 시간보다 페이지 교체 시간이 더 많아지는 현상
    * 해결책
      * 워킹 세트
        * 각 프로세스가 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하여 페이지 교체 현상을 줄이고지 하는 기법
      * 페이지 부재 빈도
        * 페이지 부재율의 상한과 하한을 정해서 직접적으로 페이지 부재율을 예측하고 조절
    * 지역성
      * 프로세스가 기억장치 내의 모든 정보를 균일하게 참조하는 것이 아니라 특정 부분만 참조하는 것
      * 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법
      * 유형
        * 시간 지역성
          * 최근 사용되었던 기억 장소들이 집중적으로 엑세스
            * Loop, Stack, Sub Routine, Counting, Totaling에 사용되는 변수
        * 공간 지역성
          * 일정 위치의 페이지를 집중적으로 액세스
          * 참조된 메모리 근처의 메모리 참조
          * 배열 순회, 관련 변수들을 서로 근처에 선언하여 기억 장소, 같은 영역에 있는 변수 참조
        * 순차 지역성
          * 데이터가 순차적으로 액세스
          * 프로그램 내의 명령어가 순차적으로 구성된 틁성

### 프로세스 스케줄링

* 프로세스 = Job, Task
* 프로세스 간 통신은 IPC, Pipe, Message, 공유 메모리 등을 사용
* 프로세스 상태 전이
  * 디스패치(할당)
    * 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당
* 프로세스 스케줄링 주요 용어
  * 서비스 시간
    * 프로세스가 결과를 산출하기까지 소요되는 시간
  * 응답 시간
    * 프로세스들이 입력되어 수행하고 결과를 산출하기까지 소요되는 시간
    * 대기시간 + 수행시간
  * 평균 응답시간
    * 대기 큐의 프로세스가 결과를 산출하기 소요되는 시간 평균
  * 대기 시간
    * 프로세스가 프로세서에 할당되기까지 큐에 대기하는 시간
  * 평균 대기시간
    * 프로세스가 대기 큐에서 대기하는 평균 시간
  * 종료 시간
    * 요구되는 Processing Time을 모두 수행하고 종료된 시간
  * 시간 할당량
    * 한 프로세스가 독점하는 것을 방지하기위해 서비스 되는 시간 할당량
  * 응답률
    * (대기시간 + 서비스 시간) / 서비스 시간
    * Highest Response ration Next 스케줄링에서 사용
    * 응답률이 높으면 우선순위가 높다고 판단
  * 스케줄링 유형
    * 선점형 스케줄링(Preemptive)
      * Shortest Remaining Time First
        * 가장 짧은 시간이 소요되는 프로세스를 먼저 수행
        * 남은 처리 시간이 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨
      * Multi-Level Qeueue
        * 작업들을 여러 종류의 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점당함
        * 독립적인 스케줄링 큐
      * Multi-level feedback queue
        * 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 할당량을 부여
        * FIFO + round robin
        * 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질수록 점점 더 낮은 우선순위 큐로 이동하고 마지막 단계는 라운드 로빈 방식을 적용
        * 큐마다 다른 시간 할당량
      * round robin
        * 프로세스는 같은 크기의 CPU 시간을 할당
        * 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내짐
        * 균등한 CPU 점유 시간
    * 비선점형 스케줄링
      * 응답시간 예상이 용이
      * 공정하게 처리
      * 우선순위
        * 각 프로세스 별로 우선순위가 주어지고, 우선순위에 따라 할당
      * Deadline
        * 작업들이 명시된 시간이나 기한 내에 완료되도록 계획
      * High Response Ration Next
        * 대기 중인 프로세스 중 대기시간이 긴 프로세스 일 경우 우선순위를 높아지게 한다.
        * 기아 현상 방지
          * 시스템 부하가 많아서 낮은 등급에 있는 준비 큐에 있는 프로세스가 무한정 기다리는 현상
      * SJF(shortest Job First);
        * 프로세스가 도착하는 시점에 따라 그 당시 가장 적은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유
        * CPU가 긴 작업은 기아 현상 발생

### 교착 상태(Deadlock)

* 다중 프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태
* 발생 조건
  * 상호 배제
    * 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없음
  * 점유와 대기
    * 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태
  * 비선점
    * 한 프로세스가 점유한 자원에 대해 다르 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능
  * 환형 대기
    * 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 형태
* 해결
  * 예방
    * 점유 자원 해제 후 새 자원 요청
  * 회피
    * 프로세스 별 자원 최대요구량 확보
    * 은행가 알고리즘
      * 안정상태일 때만 자원을 할당
  * 발견
    * 시스템의 상태를 감시 알고리즘 통해 교착 상태 검사
    * 자원할당 그래프
  * 복구
    * Deadlock이없어질 때까지 프로세스를 순차적으로 kill 하여 제거

### 환경 변수

* 프로세스가 컴퓨터에서 동작하는 방식에 많은 영향을 미치는 동적 값들이 모임이다.
* 변수들은 명령 줄 위에서 .BAT 확장자를 가지는 일괄 처리 파일 또는 스크립트 안에서 쓰일 수 있다.
* 변수 이름 앞에 특별한 기호를 놓아서 참조한다.
* 윈도우
  * SET 변수=값
* 유닉스
  * env, set, printenv 변수 없이 사용하면 모든 환경 변수 출력
  * 콜론으로 구분된 디렉터리 목록

### 쉘 스크립트

* 쉘이나 명령 줄 인터프리터에서 돌아가도록 작성되었거나 운영체제를 위해 사용되는 스크립트
* 파일 이용, 프로그램 실행, 문자열 출력
* .sh를 가리키는 것이 보통이지만, 대부분의 쉘 스크립트는 파일 확장자를 지니지 않는다.
* 쉘 스크립트라는 말은 유닉스 쉘을 위해 쓰인 스크립트를 말하는 반면 COMMAND.COM(도스)과 cmd.exe 명령 줄 스크립트는 보통 배치 파일이라고 불리지만 쉘 스크립트 안에 포함하기도 한다.

* 쉘 특징
  * 명령어 해석기
    * 명령어의 모임인 별칭, 쉘 함수 등을 찾아 실행
  * 인터페이스
    * 시스템과 사용자 간의 인터페이스
  * Bourne
    * Bash, Korn, Bourne
  * C
    * Csh, Tcsh, Zsh, Ash
*  리눅스는 최상위 유저를 #로 표시하며 일반 유저를 $로 표시한다.
* uname -a
  * 시스템의 모든 정보 확인
* uname -r
  * 운영체제의 배포 버전
* id
  * 사용자의 로그인 명, id, 그룹 id 등 출력
* last
  * 시스템의 부팅부터 현재까지의 모든 사용자의 로그인과 로그아웃 표시
* ps
  * 현재 실행되고 있는 프로세스 목록 출력
* pmap
  * 프로세스 ID를 기준으로 메모리 맵 정보를 출력하는 명령어
* kill pid
  * 특정 프로세스 종료 명령어
* fork
  * 새로운 프로세스 생성
* ifconfig
  * 네트워크 인터페이스를 설정하거나 확인
* host
  * 도메인은 알고 있는 데 ip 주소를 모 르거나 혹은 그 반대의 경우 사용
* tar
  * 여러 개의 파일을 하나의 파일로 묶거나 풀 때 사용(압축 X)
* gzip
  * 파일을 묶거나 풀 수는 없지만 압축을 담당
* find
  * 특정한 파일 찾기
* rsync
  * 로컬 또는 원격의 파일과 디렉토리를 복사하고 동기화
* df
  * 시스템에 마운트된 하드디스크의 남은 용량 확인
* du
  * 파일 사이즈를 kbyte단위로

