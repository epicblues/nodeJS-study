# 소프트웨어 개발

## 데이터 입출력 구현

- 자료 구조
  - 컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조
  - 선형 구조
    - 리스트, 스택, 큐, 데크
  - 비선형 구 조
    - 비연속적 연결
    - 트리, 그래프
  - 노드
    - 데이터 저장 부분과 포인터 부분으로 구성된 저장 공간
  - 큐
    - 데이터를 꺼내는 쪽에서 가장 가까운 데이터 : Front
    - 넣는 쪽에서 가장 가까운 데이터 : Rear
  - 트리
    - Depth
      - 루트 노드에서 특정 노드로 도달하기 위한 간선의 수
    - 차수
      - 특정 노드에 연결된 자식의 수
    - 전위 중위 후위 순회의 기준
      - 루트 노드의 방문 우선 순위
      - 전위 : 가장 먼저
      - 중위 : 가운데
      - 후위: 가장 나중에
      - 기본적으로 왼쪽에서 오른쪽으로 방문하는 것은 같다.
      - 순회 != 방문
    - 이진 트리
      - 차수가 2 이하인 노드로 구성
      - 완전 이진 트리
        - 마지막 레벨을 제외하고 노드가 채워진 트리
  - 그래프
    - 사이클
      - 동일 정점에서 시작과 끝이 이어지는 경로
  - 논리 데이터 저장소
    - 개체
      - 관리할 대상이 되는 실체
    - 속성
      - 관리할 정보의 구체적 항목
    - 관계
      - 개체 간의 대응 관계

## 물리 데이터 저장소

- 물리 데이터 저장소는 논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려하여 데이터 베이스 저장 구조(물리 데이터 모델)로 변환하기 위한 데이터 저장소이다.
  1. 단위 개체 -> 테이블
     1. 일반적으로 테이블과 개체 명칭을 동일하게 하는 것을 권고
  2. 속성 -> 컬럼
     1. 컬럼 명칭은 짧을수록 좋다.
  3. UID -> 기본 키
     1. 개체의 UID에 해당하는 모든 속성에 대해 기본 키로 선언
     2. Not null, unique 제약 조건 추가
     3. 관계에 의한 외래 키가 기본 키에 포함 될 수 있음
  4. 관계 -> 외래 키로 변환
     1. 자신의 기본 키는 외래 키로 정의(순환 관계에서)
  5. 컬럼 유형과 길이 정의
  6. 반 정규화 수행
     1. 테이블 통합
        1. 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능 향상
        2. 슈퍼타입/서브타입 테이블 통합 -> 성능 향상
     2. 테이블 분할
        1. 파티셔닝 - 테이블을 수직 또는 수평으로 분할
           1. 수평 분할
              1. 테이블 분할에 레코드를 기준으로 활용
           2. 수직 분할
              1. 하나의 테이블이 가지는 컬럼의 개수가 증가하는 경우 활용
              2. 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안 적용 필요 속성 분할
     3. 중복 테이블 추가
        1. 집계함수를 효과적으로 수행하기 위한 별도의 통계 테이블 / 중복 테이블 추가
           1. 집계 테이블 추가
           2. 진행 테이블 추가
              1. 이력 관리 목적
              2. 적절한 데이터 양의 유지를 위한 기본키 설정 필요
           3. 특정 부분만 포함하는 테이블 추가
              1. 데이터가 많은 테이블의 특정 부분만 따로 떼서 테이블 생성
     4. 컬럼 중복화
        1. 조인 성능 향상을 위한 중복 허용

### 테이블 제약 조건

- 삭제 제약 조건
  - 연쇄
    - 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 삭제
  - 제한
    - 참조한 테이블에 있는 외부 키에 없는 것만 삭제 가능
  - 무효
    - 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수장
- 갱신 제약 조건
  - 연쇄
    - 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 수정
  - 제한
    - 참조한 테이블에 있는 외부 키에 없는 것만 수정 가능
  - 무효(Nullify)
    - 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정

### Index 설계

- 분포도(Selectivity)
  - 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도이다.
  - 10~15% 이내가 좋다.
  - 조회 및 출력 조건으로 사용되는 컬럼인 경우 적용.
  - 인덱스 자동생성 기본 키와 Unique 키의 제약조건을 사용할 경우 적용.
- 인덱스 컬럼 선정
  - 분포도가 좋은 컬럼은 단독적으로 생성한다.
  - 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성한다.
  - 결합 인덱스는 구성되는 컬럼 순서 선정(사용 빈도, 유일성, 정렬 등)에 유의한다.
- 고려사항
  - 지나치게 많은 인덱스는 overhead로 작용한다.
  - 인덱스는 추가적인 저장 공간이 필요하다.
  - 넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있다.

### View 설계

- 뷰 속성

- |       속성        | 설명                                        |
  | :---------------: | ------------------------------------------- |
  |      REPLACE      | 뷰가 이미 존재하는 경우 재생성              |
  |       FORCE       | 기본 테이블의 존재 여부에 관계 없이 뷰 생성 |
  |      NOFORCE      | 기본 테이블이 존재할 때만 뷰 생성           |
  | WITH CHECK OPTION | 서브 쿼리 내의 조건을 만족하는 행만 변경    |
  |  WITH READ ONLY   | 데이터 조작어 작업 불가                     |

### 클러스터 설계

- 인덱스의 단점을 해결한 기법, 분포도가 넓을 수록 유리하다.
- 엑세스 기법이 아니라 엑세스 효율 향상을 위한 물리적 저장 기법이다.
- 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.
- 대량의 범위를 자주 엑세스 하는 경우 사용
- 인덱스를 사용하기에 부담되는 넓은 분포도에 활용
- 여러 개의 테이블이 빈번하게 조인을 일으킬때

- 고려사항
  - 검색 효율만 높여준다.(입력, 수정, 삭제 시 부하 증가)
  - UNION, DISTINCT, ORDER BY, GROUP BY가 빈번한 컬럼이면 검토 대상
  - 수정이 자주 발생하지 않는 컬럼은 검토 대상
  - 처리 범위가 넓어서 문제일 경우
    - 단일 테이블 클러스터링 사용
  - 조인이 많을 경우
    - 다중 테이블 클러스터링

### 파티션 설계

| 종류             | 설명                                                                 |
| ---------------- | -------------------------------------------------------------------- |
| 범위 분할(Range) | 분할 키값이 범위 내에 있는지 여부를 구분하는 분할 기법               |
| 해시 분할(Hash)  | 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정하는 분할 기법    |
| 목록 분할(List)  | 값 목록에 파티션을 할당하고 분할 키값을 그 목록에 맞게 분할하는 기법 |
| 조합 분할        | 범위 분할, 해시 분할, 목록 분할 중 2개 이상의 분할 기법 결정         |

- 장점
  - 성능 향상
    - 데이터 엑세스 범위를 줄여서
  - 가용성 향상
    - 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상
  - 백업 가능
    - 분할 영역을 독립적으로 백업하고 복구 가능
  - 경합 감소
    - 디스크 스트라이핑으로 입출력 성능 향상
      - 성능 향상을 위해 데이터를 1개 이상의 디스크 드라이브에 저장하여 드라이브를 병렬로 사용할 수 있는 기술이다.

### 디스크 구성 설계

- 업무량이 집중되어 있는 디스크를 분리하여 설계한다.
- 입출력 경합을 최소화하여 데이터의 접근 성능을 향상시킨다.
- 디스크 구성에 따라 테이블 스페이스 개수와 사이즈 등을 결정한다.
- 파티션 수행 테이블은 별도로 분류한다.

## ORM 프레임워크

- 관계형 데이터베이스와 객체지향 프로그래밍 언어 간 호환되지 않는 데이터를 변환하는 프로그래밍 기법.
- 객체지향 언어에서 사용하는 객체를 관계형 데이터베이스로 변환하여 테이블을 구성
- SQL Mapping(MyBatis) vs OR Mapping(Hibernate)
- 매핑 기법
  - 객체 -> 테이블
  - 속성 -> 컬럼
  - 오퍼레이션 -> 프로시저, 함수
- 절차

  - 인스턴스 -> 테이블의 레코드
  - 인스턴스의 애트리뷰트 -> 테이블 컬럼
  - 클래스 간 관계(Association, Aggregation, Generalization) -> 테이블 간 관계

- 종류

  | 구분      | 부분적 ORM                        | 완전 ORM                    |
  | --------- | --------------------------------- | --------------------------- |
  | 개요      | SQL을 특정 이름으로 정의하여 사용 | 내부 엔진에서 SQL 자동 생성 |
  | 매퍼 사용 | SQL Mapper                        | Object Relation Mapper      |
  | 방법      | MyBatis, iBatis                   | Hibernate                   |
  | 장점      | 데이터 전송 방식의 효율성         | 효율적인 매핑 기법          |

  ## 트렌젝션 인터페이스

  - 트랜잭션
    - 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위이다.
  - 트랜잭션 인터페이스는 데이터베이스 트랜잭션의 입출력과 기능 형태를 정의한 인터페이스이다.
  - 특징
    - 원자성
      - 트랜잭션 연산을 데이터베이스 모두에 반영 또는 반영하지 말아야 함.
    - 일관성
      - 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지
    - 격리성
      - 둘 이상의 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭 불가
    - 영속성
      - 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨.
  - 트랜잭션 인터페이스는 보통 프로그래밍 언어로 구현된다.

## 데이터 조작 프로시저 작성

### 프로시저

- 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 **쿼리의 집합** 이다.
- 데이터베이스 내부에 저장되고 일정한 조건이 되면 자동으로 수행된다.(외부 입력, 특정시간 등)

## 통합 구현

### 단일 모 듈

- 단일 모듈 구현의 원리
  - 정보 은닉
  - 분할과 정복
  - 데이터 추상화
    - 각 모듈 자료 구조를 액세스하고 수정하는 자료 구조의 표현 내역을 은폐
  - 모듈 독립성
    - 낮은 결합도와 높은 응집도
- 환경 변수

  - 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임

- 재사용 종류
  - 재공학
    - 기존 소프트웨어를 버리지 않고 기능을 개선시키거나 기능을 새로운 소프트웨어로 재활용하는 재사용 기법
    - 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세 오류 억제
  - 역공학
    - SW에 대한 디버깅, 디컴파일 등의 분석을 통해 기존 제품에 구현된 구조, 원리, 알고리즘 등을 역으로 분석하여 재구성하는 기법
  - 재개발
    - 기존 시스템 내용을 참조하여 완전히 새로운 시스템을 개발, 기존 시스템에 새로운 기능 추가, 기존 시스템의 기능 변경

### 단위 모듈 테스트

- 개별적인 코드단위가 예상대로 작동하는지 확인
- 종류
  - 블랙박스 테스트
    - 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능 테스트)
    - 소프트웨어 특징, 요구사항, 설계 명세서 등에 초점
    - 명세 기반 테스트
  - 화이트박스 테스트
    - 모듈 내부의 소스를 보 면서 수행하는 테스트
    - 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 수행
    - 구조 기반 테스트
  - 메서드 기반 테스트
    - 단위 모듈 외부에 공개된 메서드 기반 테스트
    - 메서드에 서로 다른 파라미터 값을 호출하면서 테스트를 수행
  - 화면 기반 테스트
    - 화면에 직접 데이터를 입력하여 테스트를 수행
    - 화면에 연계된 서비스, 비즈니스 컴포넌트 및 공통 컴포넌트를 한꺼번에 단위 모듈 테스트에 참여
    - 사용자 시나리오 기반으로 참여 가능한 장점
- 컴포넌트
  - 특정한 기능을 수행하기 위해 독립적으로 개발되어 보급하고, 다른 부품과 조립되어 응용시스템을 구축하기 위해 사용되는 소프트웨어 프로그램이다.
  - 모듈과의 차이점
    - 컴포넌트는 런타임에 독립적으로 배포되고 실행되는 단위(서버 1개, 클라이언트 5개)
    - 모듈은 정적인 구조(서버, 클라이언트)

### 형상 관리 도구의 기능

- 체크인
  - 개발자가 수정한 소스를 형상 관리 저장소로 업로드 하는 기능
- 체크아웃
  - 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드 받는 기능
- 커밋
  - 개발자가 소스를 형상 관리 저장소에 업로드 후 최종적으로 업데이트 되었을 때 형상 관리 서버에 반영하도록 하는 기능

### CVS(Concurrent Versions System)

- 중앙 집중형 서버 자장소
- 커밋 실패 등의 롤백 기능 미지원
- 일반 문서 중심

### SVN(Subversion)

- 중앙 집중형 클라이언트 - 서버 방식
- CVS 보완 -> CVS와 유사
- 바이너리 문서도 형상 관리 가능
- 롤백 지원
- 디렉토리 파일 이동 자유
- 속도
- Gzip 압축
- Trunk, Branch, Tag가 모두 물리적 저장 위치 점유
- 잦은 커밋으로 리비전 번호 크게 증가
- 개별 개발자만의 개발 이력 가질 수 없음

### Git

- 분산형 방식
- 각 PC에 스스로 완전한 저장소 구성, 필요에 따라 중앙 집중형으로 운영
- 한번에 diff 명령어를 통한 변경사항을 보기 어려움

## 제품 소프트웨어 패키징

### 애플리케이션 패키징

- 개발이 완료된 제품 소프트웨어를 배포하고, 설치할 수 있도록 고객에게 전달하기 위한 형태로 제작하고, 설치와 사용에 필요한 제반 내용을 포함하는 메뉴얼을 작성하는 활동이다.
- 사용자 중심 진행
  - 사용자 실행 환경을 우선적으로 고려
- 버전 관리 및 릴리즈 노트를 통해 고객의 편의성 강화

|        고려사항         | 설명                                                                   |
| :---------------------: | ---------------------------------------------------------------------- |
| 사용자 시스템 환경 정의 | CPU, 운영체제, 메모리 등의 수행 최소 환경                              |
|         UI 제공         | UI 제공, 메뉴얼을 일치 시켜 패키징 작업 수행                           |
| 관리 서비스 형태로 제공 | 하드웨어와 함께 통합 적용할 수 있도록 패키징을 관리 서비스 형태로 제공 |
| 변경 및 개선 관리 고려  | 다양한 사용자들의 요구 사항 반영                                       |

### 애플리케이션 패키징 프로세스

- 기능 식별
  - 입출력 데이터 식별
  - 데이터 흐름 식별
  - 기능 단위 및 출력에 대한 상세 정의
- 모듈화
  - 결합도(연관성)와 응집도(독립성) 식별
- 빌드 진행
- 사용자 환경 분석
  - 최소 사용자 환경 사전 정의
  - 모듈 단위의 사용자 환경 테스트 수행
- 적용 시험
  - 사용자 환경에서의 패키징 적용 시험
- 변경 개선
  - 변경점 도출
  - 최소 사용자 환경에서 서비스 가능한 수준의 개선
  - 개선 버전 재배포

### 애플리케이션 배포 도구

- 기술요소
  - 암호화
    - 콘텐츠 및 라이선스를 암호화하고, 전자서명을 할 수 있는 기술
  - 키 관리
    - 암호화한 키에 대한 저장 및 배포 기술(중앙집중형, vs 분산형)
  - 식별 기술
    - DOI, URI
  - 저작권 표현
    - 라이선스의 내용 표현 기술
      - ex) XrML/MPEG-21
  - 암호화 파일 생성
  - 정책 관리
    - 라이선스 발급 및 사용에 대한 정책표현 및 관리기술
      - ex) XML, 콘텐츠 관리 시스템(CMS)
  - 크랙 방지
    - 크랙에 의한 콘텐츠 사용 방지 기술
      - 난독화, Secure DB
      - 크랙
        - 소프트웨어를 수정하여 소프트웨어 복사 방지나 소프트웨어 조작 보호 등을 비활성화하거나 제거하는 일이다.
  - 인증
    - 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술
      - 사용자/장비 인증, SSO

### 애플리케이션 배포 도구 세부

- 공개키 기반 구조(PKI)
  - 공개키 암호 방식 기준으로 디지털 인증서를 활용
- 대칭 및 비대칭 암호화
  - 대칭 암호화는 해독을 위해 동일한 키 사용
  - 비대칭 암호화는 해동할 때와 암호화할 때 서로 다른 키
- 전자 서명
  - 서명자를 확인하고 서명자가 당해 전자문서에 서명했다는 사실을 나타내기 위해 특정 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보
- DOI(Digital Object Identifier)
  - 디지털 저작물에 특정한 번호를 부여하는 바코드 시스템
  - 저작권 보호 및 위치 추적
- XrML(eXtensible Right Markup Language)

  - 디지털 콘텐츠, 웹 서비스 권리 조건을 표현한 XML 기반의 마크업 언어

- MPEG-21
  - 멀티미디어 관련 요소 기술들이 통일된 형태로 상호 운용성을 보장하는 표준 규격
- 마크업 언어
  - 태그는 원래 텍스트와는 별도로 원고의 규정 부호와 주석을 표현하기 위한 수단이었으나 용도가 점차 확장되어 문서의 구조를 표현하는 역할을 하게 되었고, 이러한 태그 방법의 체계가 마크업 언어이다.
- CMS
  - 각종 콘텐츠를 생성, 수집, 관리, 배급하는 콘텐츠 생산에서 활용, 폐기까지 전공급 과정을 관리하는 기술
- 코드 난독화
  - 역공학을 통한 공격을 막기 위해서 프로그램의 소스 코드를 알아보기 힘든 형태로 기술
- Secure Db
  - 커널 암호화 방식으로 db 파일을 직접 암호화하고, 접근 제어와 감사 기록 기능이 추가된 데이터베이스 보안 강화 기술
- SSO
  - Single Sign On
  - 한번의 시스템 인증을 통하여 여러 정보 시스템에 재인증 절차 없이 접근할 수 있는 통합 로그인 기술

### DRM

- Digital Rights Management
  - 디지털 콘텐츠에 대한 권리정보를 지정하고 암호화 기술을 이용하여 허가된 사용자의 범위 내에서 콘텐츠의 이용
- 허가 받은 사용자는 별도의 비밀키를 이용하여 대상 콘텐츠를 복호화하고 허가된 권한으로 사용 가능
  - 동작 방식
    1. 라이선스 등록
       1. 클리어링 하우스에 라이선스 등록을 하면서 동시에 유통시스템 컨텐츠를 등록
    2. 라이선스 요청
       1. 콘텐츠 소비자가 유통시스템으로 라이선스 요청
    3. 라이선스 요청
       1. 유통 시스템에서 클리어링 하우스를 통해서 라이선스를 요청
    4. 요금 지불
       1. 콘텐츠 소비자가 요금 지불
    5. 라이선스 발급
       1. 클리어링 하우슬를 통해서 라이선스 발급
    6. 컨텐츠 다운로드
       1. 그 이후에 콘텐츠 소비자가 다운로드 할 수 있음.

### 국제 표준 제품 품질 특성

- ISO/IEC 9126
  - 기능성
    - 소프트웨어가 특정 조건에서 사용될 때 명시된 요구와 내재된 요구를 만족하는 기능을 제공하는 소프트웨어 제품의 능력
  - 신뢰성
    - 명세된 조건에서 사용될 때 성능 수준을 유지할 수 있는 소프트웽,ㅓ제품의 능력
    - 옳고 일관된 결과
    - 주어진 시간 주어진 기능
  - 사용성
    - 사용자에 의해 이해되고, 학습되고, 사용되고 선호될 수 있는가
  - 효율성
    - 자원의 양에 따라 요구된 성능을 제공하는 능력
  - 유지보수성
    - 소프트웨어제품이 변경되는 능력
  - 이식성
    - 한 환경에서 다른 환경으로 전이될 수 있는 소프트웨어 제품의 능력
- ISO/IEC 14598
  - 반복성
    - 특정 제품을 동일 평가자가 동일 사양으로 평가하면 동일한 결과가 나와야 한다.
  - 재현성
    - 특정 제품을 다른 평가자가 동일 사양을 평가하면 유사한 결과
  - 공정성
  - 객관성
- 국제 프로세스품질 표준
  - 9001
    - 공급자와 구매자 각각의 관리책임
  - 12207
    - 획득, 공급, 개발, 운영, 유지 보수 관리
  - 15504
    - 프로세스 평가 및 개선
  - CMMi
    - 단계별 표현
      - 조직의 전체적인 성숙도 확인
    - 연속적 표현
      - 능력 수준을 이용하여 조직의 성숙도 확인
      - 4개의 범주로 그룹화
- ISO/IEC 25000
  - 품질 평가 통합 모델
  - 4+1 구조

### 소프트웨어 공학의 기본 원칙

- 개념
  - 소프트웨어는 하드웨어를 동작시켜 사용자가 작업을 편리하게 수행하도록 하는 프로그램 및 자료구조이다.
- 소프트웨어 위기를 극복하기 위한 방안으로 연구된 학문
  - 브룩스의 법칙
    - "지체되는 소프트웨어 개발 프로젝트에 인력을 추가하는 것은 개발을 늦출 뿐이다."
  - 파레토 법칙
    - 20%의 모듈에서 80%의 결함이 발견된다.
  - 롱테일(파레토와 반대)
    - 사소해 보이는 80%의 다수가 20%의 소수 핵심보다도 뛰어난 가치를 창출해낸다.

## 제품 소프트웨어 버전 관리

### 버전 관리 도구

- 공유 폴더 방식

  - RCS(Revision Control System -> 한 사람만 소스 파일 수정 가능), SCCS
    - 개발 완료 파일을 약속된 위치의 공유 폴더에 복사
    - 개발자 한 명이 매일 공유 폴더의 파일을 자기 PC로 복사하고 컴파일하여 에러 확인과 동작 여붛 ㅗ가인

- 클라이언트/서버 방식
  - CVS, SVN
  - 중앙에 버전 관리 시스템으 항상 동작
  - 서로 다른 개발자가 같은 파일을 작업했을 때 경고 메시지 출력
- 분산 저장소 방식
  - Git, Bitkeeper
- 백업의 유형
  - 전체 백업
    - 백업받고자 하는 데이터 전체에 대해 백업
  - 차등 백업
    - 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식
  - 증분 백업
    - 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업
- Bundle
  - 개념상 관련된 파일들을 모두 하나로 묶어주는 꾸러미로 애플리케이션, 프레임워크나, 플러그인의 실행 파일을 의미한다.

### 빌드 자동화 도구

- 빌드
  - 소프트웨어를 생성하고 테스트하고 검사하여 배포하기 위해 수행하는 행위의 집합이다.
- 빌드 자동화 도구
  - 제품 소프트웨어 실행 파일을 자동화하기 위해서 저장소에 있는 소스를 자동으로 읽어서 빌드한 후 테스트하고 검사하여 실행파일을 만드는 도구이다.
  - 지속적인 통합과도 연관
    - 지속해서 품질제어를 적용하는 프로세스를 실행하는 기법으로, 소프트웨어 릴리스 프로세스 중 빌드 또는 통합 단계에 적용된다.
- 빌드 자동화 프로세스
  1. 컴파일
  2. 패키징(바이너리 -> 배포 형태)
  3. 단위 테스트(커버리지 포함)
  4. 정적 분석
  5. 리포팅
  6. 배포(테스트 서버에)
  7. 최종 빌드
- 빌드 자동화 구성요소
  - 형상 관리 서버에 저장된 소스 코드를 주기적으로 가져와서 컴파일, 단위 테스트, 코드 검사 등의 과정을 수행하며 신규 또는 수정된 소스 코드가 결함이 있는지의 여부를 지속적으로 검증한다.
  - 검증 결과는 이메일 등의 피드백을 통해 개발자들에게 전달된다.
  - CI 서버
    - 빌드 프로세스를 관리하는 서버
    - Jenkins, Hudson
  - SCM
    - SVG, Git
  - 빌드 도구
    - 컴파일, 테스트, 정적 분석 등을 통해 동작 가능한 소프트웨어 생성
    - Ant, Maven
  - 테스트 도구
    - 작성된 테스트 코드에 따라 자동으로 테스트를 수행해주는 도구로, 빌드 도구의 스크립트에서 실행
    - JUnit,Selenium
  - 테스트 커버리지 도구
    - 테스트 코드가 대상 소스 코 드에 대해 어느 정도 커버하는지 분석하는 도구
    - Emma
  - 인스펙션 도구
    - 프로그램을 실행하지 않고, 소스 코드 자체로 품질을 판단할 수 있는 정적 분석 도구
    - 코딩 표준 준수 검사, 코드 메트릭 측정, 중복 코드 검사, 코드 인스펙션 검사
    - 코드 인스펙션
      - 개발 표준에 위배되었거나, 코드가 중복 또는 작성 규칙에 맞지 않거나 잘못 구현된 부분을 수정하는 ㅈ가업
- 빌드 자동화 도구의 기능

  - 코드 컴파일
    - 테스트 포함 코드 컴파일
  - 컴포넌트 패키징
    - jar파일이나 exe파일 같은 배포할 수 있는 컴포넌트를 묶는 작업
  - 파일 조작
    - 파일과 디렉토리를 만들고, 복사 및 지우는 작업
  - 개발 테스트 실행
  - 버전 관리 도구 통합
  - 문서 생성
    - API 문서 생성
  - 배포 기능
    - 테스트 서버 배포 기능
  - 코드 품질 분석

- Jenkins
  - 서블릿 컨테이너 기반
    - 서블릿
      - 서블릿 컨테이너 위에서 작동하는 웹 서비스용 자바 인터페이스의 객체(애플리케이션)이다.
    - 서블릿 컨테이너
      - 서블릿을 관리하고 동작시킬 수 있는 환경을 제공하는 서버 프로그램
  - Jenkins.war 파일로 제공
    - java -jar jenkins.war 명령어로 설치 가능
- Gradle
  - 안드로이드 공식 자동화
  - 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.

## 애플리케이션 테스트 관리

## 테스트 케이스

- 입력값, 실행 조건, 예상된 결과의 집합

### 테스트 오라클

- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 방법
- 참 오라클
  - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생하는 오류를 모두 검출하는 오라클
- 샘플링 오라클
  - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클
- 휴리스틱 오라클
  - 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클
- 일관성 검사 오라클
  - 애플리케이션 변경이 있을 때 수행 전과 후의 결과값이 동일한지 확인하는 오라클

### 테스트 레벨

- 함꼐 편성되고 관리되는 테스트 활동의 그룹이다.
- 테스트 레벨은 프로젝트에서 책임과 연관되어 있다.
- 각각의 테스트 레벨은 서로 독립적이다.

- 종류
  - 단위 테스트
    - 사용자 요구사항에 대한 단위 모듈, 서브 루틴 등을 테스트 하는 단계
      - 인터페이스 테스트
      - 자료 구조 테스트
      - 실행 경로 테스트
      - 오류 처리 테스트
    - 모듈과 컴포넌트 중심
    - 인터페이스, 외부적 I,O, 독립적 기초 경로
    - 주로 구조 기반 테스트(화이트박스)
  - 통합 테스트
    - 단위 테스트를 통과한 컴포넌트 간의 인터페이스를 테스트 하는 단계
      - 빅뱅 테스트
      - 상향/하향식 테스트
  - 시스템 테스트
    - 개발 프로젝트 차원에서 정의된 전체 시스템 또는 제품의 동작에 대해 테스트
    - 비기능/기능 요구사항 테스트
    - 컴퓨터 시스템을 완벽하게 검사하기 위한 목적
    - 기능적 요구사항 테스트
      - 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트
    - 비기능적 요구사항
      - 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 네비게이션 등의 구조적 요소에 대한 화이트박스 테스트
  - 인수 테스트
    - 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계
      - 사용자 인수 테스트
        - 비즈니스 사용자가 시스템 사용의 적절성 여부 확인
      - 운영상의 인수 테스트
        - 시스템 관리자가 시스템 인수 시 수행하는 테스트 활동으로
        - 백업/복원 시스템
        - 재해 복구
        - 사용자 관리
        - 정기 점검
      - 계약 인수 테스트
        - 계약상의 인수/검수 조건을 준수하는가
      - 규정 인수 테스트
        - 정부 지침, 법규, 규정 등이 맞는가
      - 알파 테스트
        - 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트
      - 베타 테스트
        - 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트

### 테스트 지식 쳬게

|    분류     | 설명                                              | 유형                                           |
| :---------: | ------------------------------------------------- | ---------------------------------------------- |
| 정적 테스트 | 테스트 대상을 실행 x, 구조를 분석하여 논리성 검증 | 리뷰(동료 검토, 워크스루, 인스펙션), 정적 분석 |
| 동적 테스트 | 실행해서 결함 검출                                | 화이트박스, 블랙박스, 경험 기반                |

- 화이트박스 테스트 유형
  - 구문 커버리지(Statement Coverage)
    - 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
    - 구문 실행 개수로 계산
  - 결정,선택,분기 커버리지(Decision, Dracnh)
    - 결정 포인트 내이ㅡ **전체** 조건식이 적어도 한 번은 참과 거짓 결과를 수행하는 테스트 커버리지
  - 조건 커버리지
    - 각 **개별** 조건식이 적어도 한 번은 참과 거짓
  - 조건 / 결정 커버리지
    - 전체 조건식 + 개별 조건식
  - 변경 조건/ 결정 커버리지
    - 개별 조건식이 독립적으로 전체 조건식에 영향을 주도록 한다.
  - 다중 조건
    - 모든 개별 조건식의 모든 가능한 조합 100% 보장
  - 기본 경로
    - 수행 가능한 모든 경로 테스트
  - 제어 흐름
    - 제어구조를 그래프 형태로 나타내어 내부 로직 테스트
  - 데이터 흐름
    - 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프로 테스트
- 블랙박스
  - 동등 분할
    - 입력 데이터 영역을 유효/무효 값 그룹핑
  - 경곗값
    - 등가분할 후 경곗값 부분에서 오류 테스트
  - 결정 테이블
    - 요구사항의 논리와 발생 조건을 테이블 형ㅇ태로 나열하여 모든 조건과 행위를 조합하여 테스트
  - 상태전이
    - 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행
  - 유스케이스
    - 프로세스 흐름 기반으로 테스트 케이스 명세화 및 수행
  - 분류 트리
    - SW의 일부 또는 전체를 트리 구조로 분석 및 표현
  - 페어와이즈
    - 테스트 데이터 간의 최소 한 번씩을 조합
  - 원인-결과
    - 입력 데이터간의 관계 및 출력에 미치는 영향 분석
    - 효용성이 높은 테스트 케이스 선정 및 테스트
  - 비교
    - 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과가 나오는가.
- 테스트 시각에 따른 분류
  - 검증
    - 개발 과정
    - 개발자 혹은 시험자 관점
  - 확인
    - 결과
    - 제품이 제대로 동작하는가
    - 최종 사용자 시각
- 목적에 따른 분류

  - 회복
    - 고의로 실패 유도, 정상적 복귀 여부 테스트
  - 안전
    - 소스 코드 내의 보안적인 결함 미리 점검
  - 성능
    - 사용자의 이벤트에 시스템이 응답하는 시간, 반응 속도 등
  - 구조
    - 내부 논리 경로, 소스 코드 복잡도
  - 회귀
    - 오류를 제거하거나 수정한 시스템에에서 사용
    - 새로 유입된 오류가 없는지 일종의 반복 테스트
  - 병행
    - 변경된 시스템과 새로운 시스템에 동일한 데이터 입력후 결과 비교

- 테스팅은 결함이 없다는 것을 증명할 수는 없다.
- 결함을 줄이는 활동
- 완벽한 테스팅 불가
- 개발 초기에 테스팅 시작
  - 테스팅 결과 단시간 파악
  - 기간 단축
  - 재작업 줄이기
  - Snowball Effect
- 결함 집중
  - 파레토 법칙 적용
- 살충제 패러독스
  - 동일한 테스트 케이스에 의한 반복적 테스트 -> 새로운 버그 찾지 못함
  - 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근 필요
- 정황 의존적(상황에 맞게 테스트)
- 오류 - 부재의 궤변
  - 오류가 없다-> 품질이 높다 (X)

## 애플리케이션 통합 테스트

### 결함

- 개발자 오류로 인해 만들어지는 문서 또는 코딩상의 결점

- 에러
  - 결함의 원인
  - 일반적으로 사람에 의해 생성된 실수
- 결함/결점/버그
  - 에러 또는 오류가 원인이 되어 소프트웨어 제품에 포함되어 있는 결함
  - 제거하지 않으면 소프트웨어의 실패나 문제 발생
- 실패/문제

  - 결함이 실행될 때 발생되는 현상

- 장애(Failure)
  - 시스템이 결함으로 인해 사용자가 기대하는 서비스를 제공하지 못하거나 의도하지 않은 동작이 나타나느는 상태

### 테스트 자동화 도구

- 반복적인 테스트 작업을 스크립트 형태로 구현

- 테스트 실행 도구 유형
  - 데이터 주도 접근 방식
    - 데이터를 스프레드시트에 저장, 읽고 실행
    - 동일한 테스트 케이스를 반복해서 실행
  - 키워드 주도 접근 방식
    - 테스트 동작을 나타내는 키워드와 데이터를 스프레드 시트에 저장
    - 키워드를 이용하여 동작 정의, 테일러링 가능
      - 테일러링 : 프로젝트 특성과 필요에 따라 개발 프로세스를 적합한 규모로 가공
- 테스트 장치 구성요소
  - 테스트 드라이버
    - 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트수행 후의 결과를 도출
    - 상향식 테스트에 필요
  - 테스트 스텁(stub)
    - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
    - 하향식 테스트에 필요
  - 테스트 슈트
    - Test case를 실행환경에 따라 구분해놓은 TestCase의 집합
    - 단, 시나리오 포함 X
  - 테스트 시나리오
    - 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서
    - 하나 또는 여러개의 테스트 케이스 포함할 수 있음
    - 테스트 케이스와 일대 다 관계
  - 테스트 스크립트
    - 테스트 실행 순서 작성
    - 테스트 스텝, 절차서 라고도 불림
  - 목 오브젝트
    - 상황에 예정된 행위르르 수행과 객체.

### 해싱 함수

- 임의의 길이의 데이터를 고정된 길이의 데이터로 해싱하는 함수이다.

|    함수     | 설명                                                                                                                                                         |
| :---------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|   제산법    | 나머지 연산자를 사용하여 테이블 주소를 계산하는 방식                                                                                                         |
|   제곱법    | 레코드 키값을 제곱한 후에 결괏값의 중간 부분에 있는 몇 비트를 선택하여 해시 테이블으 홈 주소로 사용                                                          |
| 숫자 분석법 | 레코디 키를 구성하는 수들이 모든 키들 내에세서 자리 별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택하여 , 홈 주소로 선택 |
|   폴딩법    | 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈주소                                                                           |
| 기수 변환법 | 다른 진법으로 간주하고 키를 변환하여 얻는 방식                                                                                                               |
|   무작위    | 난수를 발생시켜 홈 주소 결정                                                                                                                                 |

# 인터페이스 구현

### EAI(Enterprise Application Integration)

- 포인트 투 포인트
  - 중간에 미들웨어를 두지 않고 각각의 애플리케이션 간의 점대점 형태로 연결
- 허브 앤 스포크
  - 단일한 접점의 허브시스템을 통하여 데이터를 중앙 집중식 방식
  - 허브 장애시 전체 장애 발생
- 메시지 버스
  - 애플리케이션 사이 미들웨어(버스)를 두어 연계하는 미들웨어통합 방식
  - 확장성, 대용량 데이터
- 하이브리드
  - 그룹 내에서는 허브 앤 스포크 방식
  - 그룹 밖에서는 버스 방식

### Enterprise Service Bus

- 버스를 중심으로 각각 포로토콜이 호환이 가능하도록 애플리케이션의 통합을 낮은 결합 방식으로 지원

### 시큐어 코딩 가이드

| 적용 대상                | 보안 약점                                                                                                   | 대응 방안                                                                              |
| ------------------------ | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| 입력 데이터 검증 및 표현 | 프로그램 입력값에 대한 검증 누락, 부적절한 검증, 잘못된 형식 지정                                           | 유효성 검증 체계 수립, 사용자 실패시 처리 설계 구현                                    |
| 보안 기능                | 보안 기능의 부적절한 구현                                                                                   | 인증\*접근 통제, 권한 관리, 비밀 번호 등의 정책 적절하게 반영되도록                    |
| 시간 및 상태             | 거의 동시에 수행 지원하는 병렬 시스템, 하나 이상의프로세스가 동작하는 환경에서 시간 및 상태의 부적절한 관리 | 공유자원의 접근 직렬화, 병렬 실행 가능 프레임워크 사용, 블록문 내에서만 재귀 함수 호출 |
| 에러 처리                | 에러 처리, 불충분한 처리, 에러 메시지에 중요 정보 포함                                                      | 중요 정보 유출 않도록 보안                                                             |
| 코드오류                 | 코딩 오류                                                                                                   | 코딩 규칙 도출 -> 검증 가능한 스크립트 구성, 경고 순위 조정                            |
| 캡슐화                   | 불충분한 캡슐화 -> 인가되지 않은 사용자에게 데이터 누출                                                     | 디버거 코드 제거와 필수정보 외의 클래스 프라이빗 접근자 지정                           |
| API 오용                 | 사용에 반하는 방법으로 API 사용, 보안 취약 API                                                              | API 검출 프로그램                                                                      |

### 암호화 알고리즘

- 대칭 키
  - 같은 암호 키
  - ARIA 128/192/256, SEED
- 비대칭
  - RSA, ECC, ECDSA
- 해시
  - 해시 값으로 원래 입력값을 찾아낼 수 없는, 일방향 특성
  - SHA-256/384/512, HAS-160

### 중요 인터페이스 데이터의 암호화 전송

- IPSec(IP security)
  - IP 계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안 서비스를 제공하는 터널링 프로토콜
  - 동작 모드는 전송 모드와 터널 모드
  - 주요 프로토콜은 AH, ESP, IKE(키 교환)
- SSL/TLS
  - 전송게층(4),와 응용계층(7)사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜
  - 인증 모드는 익명 모드, 서버 인증 모드, 클라이언트 - 서버 인증 모드가 있음
  - IPSec하고는 다르게 Client와 Server 간에 상호 인증, 암호 방식에 대해 협상을 거치는 특징
  - 특정 암호 기술에 의존하지 않음
  - https://~ 표시형식과 443포트 이용
- S-HTTP
  - 웹상에서 트래픽 암호화, 모든 메시지 암호화 전송
  - http 사용 애플리케이션에서만 적용

## 인터페이스 구현 검증

- xUnit
  - javja, c++, .Net 등 다양한 언어를 지원하는 단위 테스트 프레임워크
  - 함수나 클래스 같은 서로 다른 구성 원소를 테스트 할 수 있게 해주는 도구
- STAF
  - 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
